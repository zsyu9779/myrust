use num::complex::Complex;
fn main() {
    //++++++++++++++++++++++++++++++++++++++++++++++++++++å˜é‡ç»‘å®šä¸è§£æ„++++++++++++++++++++++++++++++++++++++++++++++++++++++
    let a = "hello world!";
    println!("{}", a);

    // let b = 5; åˆ›å»ºçš„æ˜¯ä¸å¯å˜å˜é‡
    let mut b = 5;
    println!("{}", b);
    b = 6;
    println!("{}", b);

    let _x = 5;
    let _y = 10;

    let (aa, mut bb): (bool, bool) = (true, false);
    println!("aa = {:?}, bb = {:?}", aa, bb);
    bb = true;
    assert_eq!(aa, bb);

    let (a, b, c, d, e);
    (a, b) = (1, 2);
    [c, .., d, _] = [1, 2, 3, 4, 5];
    Struct { e, .. } = Struct { e: 5 };
    assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]);

    //===============å˜é‡é®è”½=====================
    let x = 5;
    //åœ¨mainå‡½æ•°çš„ä½œç”¨åŸŸå¯¹xè¿›è¡Œé®è”½
    let x = x + 1;

    {
        //åœ¨{}çš„ä½œç”¨åŸŸå†…å¯¹xè¿›è¡Œé®è”½
        let x = x * 2;
        println!("the x in scope is {}", x)
    }
    println!("the x in main is {}", x);
    /*
        ä»¥ä¸Šå†™æ³•å’Œmutå˜é‡ä¸åŒç‚¹æ˜¯ mut å¯ä»¥ä¿®æ”¹åœ¨åŒä¸€ä¸ªå†…å­˜åœ°å€ä¸Šçš„å€¼ï¼Œä¸ä¼šå‘ç”Ÿå†…å­˜å¯¹è±¡çš„å†åˆ†é…ï¼Œæ€§èƒ½æ›´å¥½
        è€Œå˜é‡é®è”½ç”Ÿæˆäº†å®Œå…¨ä¸åŒçš„æ–°å˜é‡ï¼Œåªæ˜¯åˆšå¥½åŒåã€‚å˜é‡é®è”½çš„ç”¨å¤„åœ¨äºï¼Œå¦‚æœä½ åœ¨æŸä¸ªä½œç”¨åŸŸå†…æ— éœ€å†ä½¿ç”¨ä¹‹å‰çš„å˜é‡ï¼ˆåœ¨è¢«é®è”½åï¼Œæ— æ³•å†è®¿é—®åˆ°ä¹‹å‰çš„åŒåå˜é‡ï¼‰ï¼Œå°±å¯ä»¥é‡å¤çš„ä½¿ç”¨å˜é‡åå­—ï¼Œè€Œä¸ç”¨ç»å°½è„‘æ±å»æƒ³æ›´å¤šçš„åå­—ã€‚
    */

    //++++++++++++++++++++++++++++++++++++++++++++++++++++åŸºæœ¬ç±»å‹++++++++++++++++++++++++++++++++++++++++++++++++++++++

    //===============æ•°å€¼ç±»å‹=====================

    //æ•´å½¢æº¢å‡º
    //let a :u8 = 256; //è¿™ç§å†™æ³•æ­£å¸¸æƒ…å†µåœ¨ç¼–è¯‘æ—¶ä¼šæŠ¥é”™: the literal `256` does not fit into the type `u8` whose range is `0..=255`
    let a: u8 = 255;
    /*
        ä½¿ç”¨ wrapping_* æ–¹æ³•åœ¨æ‰€æœ‰æ¨¡å¼ä¸‹éƒ½æŒ‰ç…§è¡¥ç å¾ªç¯æº¢å‡ºè§„åˆ™å¤„ç†ï¼Œä¾‹å¦‚ wrapping_add
        å¦‚æœä½¿ç”¨ checked_* æ–¹æ³•æ—¶å‘ç”Ÿæº¢å‡ºï¼Œåˆ™è¿”å› None å€¼
        ä½¿ç”¨ overflowing_* æ–¹æ³•è¿”å›è¯¥å€¼å’Œä¸€ä¸ªæŒ‡ç¤ºæ˜¯å¦å­˜åœ¨æº¢å‡ºçš„å¸ƒå°”å€¼
        ä½¿ç”¨ saturating_* æ–¹æ³•ä½¿å€¼è¾¾åˆ°æœ€å°å€¼æˆ–æœ€å¤§å€¼
     */
    let b = a.wrapping_add(20);
    let c = a.wrapping_mul(2);
    println!("a = {}", a);
    println!("b = {}", b);
    println!("c = {}", c);

    //æµ®ç‚¹ç±»å‹
    //ä¸¤ç§åŸºæœ¬ç±»å‹ f32 å’Œ f64
    let x = 0.1; // f64
    let y: f32 = 0.02; // f32
    /*
        Rust çš„æµ®ç‚¹æ•°ç±»å‹éµå¾ª IEEE-754 æ ‡å‡†
        æµ®ç‚¹æ•°å¤§éƒ¨åˆ†æƒ…å†µä¸‹æ˜¯ä¸ç²¾ç¡®çš„ï¼Œæ‰€ä»¥ä¸è¦ç”¨ == æ¯”è¾ƒæµ®ç‚¹æ•°
    */
    assert_eq!(x + y == 0.12, false);
    /*
    thread 'main' panicked at 'assertion failed: `(left == right)`
    left: `0.120000005`,
    right: `0.12`', src/main.rs:69:5
    */

    let abc: (f32, f32, f32) = (0.1, 0.2, 0.3);
    let xyz: (f64, f64, f64) = (0.1, 0.2, 0.3);

    println!("abc (f32)");
    println!("   0.1 + 0.2: {:x}", (abc.0 + abc.1).to_bits());
    println!("         0.3: {:x}", (abc.2).to_bits());
    println!();

    println!("xyz (f64)");
    println!("   0.1 + 0.2: {:x}", (xyz.0 + xyz.1).to_bits());
    println!("         0.3: {:x}", (xyz.2).to_bits());
    println!();

    assert_eq!(abc.0 + abc.1, abc.2);
    // ç”±äºf64ç²¾åº¦é«˜äºf32 æ‰€ä»¥ä¸‹é¢è¿™ä¸ªæ–­è¨€ä¼španic
    //assert_eq!(xyz.0 + xyz.1, xyz.2);

    //========NaN=====
    //NaN æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„æµ®ç‚¹æ•°ï¼Œè¡¨ç¤ºéæ•°å­—ï¼ˆNot a Numberï¼‰
    //NaN ä¸ä»»ä½•å€¼éƒ½ä¸ç›¸ç­‰ï¼ŒåŒ…æ‹¬å®ƒè‡ªå·±
    let nan = (-42.0_f32).sqrt();
    assert_eq!(nan != nan, true);
    //åˆ¤æ–­ä¸€ä¸ªå€¼æ˜¯å¦æ˜¯nan ä½¿ç”¨ is_nan æ–¹æ³•
    assert_eq!(nan.is_nan(), true);

    //æ•°å€¼è¿ç®— æ²¡ä»€ä¹ˆç‰¹åˆ«
    // åŠ æ³•
    let sum = 5 + 10;

    // å‡æ³•
    let difference = 95.5 - 4.3;

    // ä¹˜æ³•
    let product = 4 * 30;

    // é™¤æ³•
    let quotient = 56.7 / 32.2;

    // æ±‚ä½™
    let remainder = 43 % 5;

    println!("sum = {}, difference = {}, product = {}, quotient = {}, remainder = {}", sum, difference, product, quotient, remainder);

    //èµ‹å€¼æ–¹æ³•
    //ç¼–è¯‘å™¨ä¼šæ ¹æ®å€¼è‡ªåŠ¨æ¨æ–­å˜é‡ç±»å‹
    let _a = 20;
    //æ˜¾å¼æŒ‡å®šç±»å‹
    let _a: i32 = 20;
    //åç¼€æŒ‡å®šç±»å‹
    let _a = 20i32;
    let _a = 20_i32;
    //åŒæ ·ç±»å‹çš„å˜é‡æ‰å¯ä»¥è¿ç®—

    //å¯¹äºè¾ƒé•¿çš„æ•°å­—ï¼Œå¯ä»¥ä½¿ç”¨ä¸‹åˆ’çº¿æ¥æé«˜å¯è¯»æ€§
    let a = 1_000_000;
    println!("a = {}", a);

    // å®šä¹‰ä¸€ä¸ªf32æ•°ç»„ï¼Œå…¶ä¸­42.0ä¼šè‡ªåŠ¨è¢«æ¨å¯¼ä¸ºf32ç±»å‹
    let forty_twos = [
        42.0,
        42f32,
        42.0_f32,
    ];
    // æ‰“å°æ•°ç»„ä¸­ç¬¬ä¸€ä¸ªå€¼ï¼Œå¹¶æ§åˆ¶å°æ•°ä½ä¸º2ä½
    println!("{:.2}", forty_twos[0]);

    //===============ä½è¿ç®—=====================
    let a:i32 = 2; // äºŒè¿›åˆ¶ 0000 0010
    let b:i32 = 3; // äºŒè¿›åˆ¶ 0000 0011
    println!("a & b = {}", a & b); // 0000 0010
    println!("a | b = {}", a | b); // 0000 0011
    println!("a ^ b = {}", a ^ b); // 0000 0001
    println!("!a = {}", !a); // 1111 1101
    println!("a << 1 = {}", a << 1); // 0000 0100
    println!("a >> 1 = {}", a >> 1); // 0000 0001

    //===============åºåˆ—=====================
    // rustæä¾›äº†ä¸€ç§ç®€ä»‹çš„æ–¹å¼ ç”Ÿæˆè¿ç»­çš„æ•°å­—åºåˆ—
    // .. ç”Ÿæˆä¸€ä¸ªå·¦é—­å³å¼€çš„åŒºé—´
    for  i in 0..5 {
        println!("i = {}", i);
    }
    // ..= ç”Ÿæˆä¸€ä¸ªå·¦é—­å³é—­çš„åŒºé—´
    for  i in 5..=10 {
        println!("i = {}", i);
    }
    //åºåˆ—åªå…è®¸ç”¨äºæ•´æ•°æˆ–å­—ç¬¦ç±»å‹ å› ä¸ºä»–ä»¬å¯ä»¥è¿ç»­
    for c in 'a'..='z' {
        print!("{}  ", c);
    }
    //ä½¿ç”¨aså®Œæˆç±»å‹è½¬æ¢
    for i in 0..5 {
        println!("i = {:.2}", i as f32);
    }

    //æœ‰ç†æ•°å’Œå¤æ•° æœ‰ç†æ•°å’Œå¤æ•°æœªåŒ…å«åœ¨æ ‡å‡†åº“ä¸­ï¼Œéœ€è¦å¼•å…¥ç¬¬ä¸‰æ–¹åº“

    let a = Complex { re: 1.0, im: 2.0 };
    let b = Complex::new(3.0, 4.0);
    let result = a + b;
    println!("result = {}", result);

    //rustä¸­çš„å­—ç¬¦ç±»å‹
    let c = 'å¼ '; //å•ä¸ªæ±‰å­—
    let emoji = 'ğŸ˜»'; //emojiè¡¨æƒ…
    let japanese = 'ã®'; //æ—¥æ–‡
    println!("c = {}, emoji = {}, japanese = {}", c, emoji, japanese);

}

struct Struct {
    e: i32,
}
