use std::fmt::{Debug, Display};
use std::ops::Index;
use num::complex::Complex;

fn main() {
    //++++++++++++++++++++++++++++++++++++++++++++++++++++å˜é‡ç»‘å®šä¸è§£æ„++++++++++++++++++++++++++++++++++++++++++++++++++++++
    let a = "hello world!";
    println!("{}", a);

    // let b = 5; åˆ›å»ºçš„æ˜¯ä¸å¯å˜å˜é‡
    let mut b = 5;
    println!("{}", b);
    b = 6;
    println!("{}", b);

    let _x = 5;
    let _y = 10;

    let (aa, mut bb): (bool, bool) = (true, false);
    println!("aa = {:?}, bb = {:?}", aa, bb);
    bb = true;
    assert_eq!(aa, bb);

    let (a, b, c, d, e);
    (a, b) = (1, 2);
    [c, .., d, _] = [1, 2, 3, 4, 5];
    Struct { e, .. } = Struct { e: 5 };
    assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]);

    //===============å˜é‡é®è”½=====================
    let x = 5;
    //åœ¨mainå‡½æ•°çš„ä½œç”¨åŸŸå¯¹xè¿›è¡Œé®è”½
    let x = x + 1;

    {
        //åœ¨{}çš„ä½œç”¨åŸŸå†…å¯¹xè¿›è¡Œé®è”½
        let x = x * 2;
        println!("the x in scope is {}", x)
    }
    println!("the x in main is {}", x);
    /*
        ä»¥ä¸Šå†™æ³•å’Œmutå˜é‡ä¸åŒç‚¹æ˜¯ mut å¯ä»¥ä¿®æ”¹åœ¨åŒä¸€ä¸ªå†…å­˜åœ°å€ä¸Šçš„å€¼ï¼Œä¸ä¼šå‘ç”Ÿå†…å­˜å¯¹è±¡çš„å†åˆ†é…ï¼Œæ€§èƒ½æ›´å¥½
        è€Œå˜é‡é®è”½ç”Ÿæˆäº†å®Œå…¨ä¸åŒçš„æ–°å˜é‡ï¼Œåªæ˜¯åˆšå¥½åŒåã€‚å˜é‡é®è”½çš„ç”¨å¤„åœ¨äºï¼Œå¦‚æœä½ åœ¨æŸä¸ªä½œç”¨åŸŸå†…æ— éœ€å†ä½¿ç”¨ä¹‹å‰çš„å˜é‡ï¼ˆåœ¨è¢«é®è”½åï¼Œæ— æ³•å†è®¿é—®åˆ°ä¹‹å‰çš„åŒåå˜é‡ï¼‰ï¼Œå°±å¯ä»¥é‡å¤çš„ä½¿ç”¨å˜é‡åå­—ï¼Œè€Œä¸ç”¨ç»å°½è„‘æ±å»æƒ³æ›´å¤šçš„åå­—ã€‚
    */

    //++++++++++++++++++++++++++++++++++++++++++++++++++++åŸºæœ¬ç±»å‹++++++++++++++++++++++++++++++++++++++++++++++++++++++

    //===============æ•°å€¼ç±»å‹=====================

    //æ•´å½¢æº¢å‡º
    //let a :u8 = 256; //è¿™ç§å†™æ³•æ­£å¸¸æƒ…å†µåœ¨ç¼–è¯‘æ—¶ä¼šæŠ¥é”™: the literal `256` does not fit into the type `u8` whose range is `0..=255`
    let a: u8 = 255;
    /*
        ä½¿ç”¨ wrapping_* æ–¹æ³•åœ¨æ‰€æœ‰æ¨¡å¼ä¸‹éƒ½æŒ‰ç…§è¡¥ç å¾ªç¯æº¢å‡ºè§„åˆ™å¤„ç†ï¼Œä¾‹å¦‚ wrapping_add
        å¦‚æœä½¿ç”¨ checked_* æ–¹æ³•æ—¶å‘ç”Ÿæº¢å‡ºï¼Œåˆ™è¿”å› None å€¼
        ä½¿ç”¨ overflowing_* æ–¹æ³•è¿”å›è¯¥å€¼å’Œä¸€ä¸ªæŒ‡ç¤ºæ˜¯å¦å­˜åœ¨æº¢å‡ºçš„å¸ƒå°”å€¼
        ä½¿ç”¨ saturating_* æ–¹æ³•ä½¿å€¼è¾¾åˆ°æœ€å°å€¼æˆ–æœ€å¤§å€¼
     */
    let b = a.wrapping_add(20);
    let c = a.wrapping_mul(2);
    println!("a = {}", a);
    println!("b = {}", b);
    println!("c = {}", c);

    //æµ®ç‚¹ç±»å‹
    //ä¸¤ç§åŸºæœ¬ç±»å‹ f32 å’Œ f64
    let x = 0.1; // f64
    let y: f32 = 0.02; // f32
    /*
        Rust çš„æµ®ç‚¹æ•°ç±»å‹éµå¾ª IEEE-754 æ ‡å‡†
        æµ®ç‚¹æ•°å¤§éƒ¨åˆ†æƒ…å†µä¸‹æ˜¯ä¸ç²¾ç¡®çš„ï¼Œæ‰€ä»¥ä¸è¦ç”¨ == æ¯”è¾ƒæµ®ç‚¹æ•°
    */
    assert_eq!(x + y == 0.12, false);
    /*
    thread 'main' panicked at 'assertion failed: `(left == right)`
    left: `0.120000005`,
    right: `0.12`', src/main.rs:69:5
    */

    let abc: (f32, f32, f32) = (0.1, 0.2, 0.3);
    let xyz: (f64, f64, f64) = (0.1, 0.2, 0.3);

    println!("abc (f32)");
    println!("   0.1 + 0.2: {:x}", (abc.0 + abc.1).to_bits());
    println!("         0.3: {:x}", (abc.2).to_bits());
    println!();

    println!("xyz (f64)");
    println!("   0.1 + 0.2: {:x}", (xyz.0 + xyz.1).to_bits());
    println!("         0.3: {:x}", (xyz.2).to_bits());
    println!();

    assert_eq!(abc.0 + abc.1, abc.2);
    // ç”±äºf64ç²¾åº¦é«˜äºf32 æ‰€ä»¥ä¸‹é¢è¿™ä¸ªæ–­è¨€ä¼španic
    //assert_eq!(xyz.0 + xyz.1, xyz.2);

    //========NaN=====
    //NaN æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„æµ®ç‚¹æ•°ï¼Œè¡¨ç¤ºéæ•°å­—ï¼ˆNot a Numberï¼‰
    //NaN ä¸ä»»ä½•å€¼éƒ½ä¸ç›¸ç­‰ï¼ŒåŒ…æ‹¬å®ƒè‡ªå·±
    let nan = (-42.0_f32).sqrt();
    assert_eq!(nan != nan, true);
    //åˆ¤æ–­ä¸€ä¸ªå€¼æ˜¯å¦æ˜¯nan ä½¿ç”¨ is_nan æ–¹æ³•
    assert_eq!(nan.is_nan(), true);

    //æ•°å€¼è¿ç®— æ²¡ä»€ä¹ˆç‰¹åˆ«
    // åŠ æ³•
    let sum = 5 + 10;

    // å‡æ³•
    let difference = 95.5 - 4.3;

    // ä¹˜æ³•
    let product = 4 * 30;

    // é™¤æ³•
    let quotient = 56.7 / 32.2;

    // æ±‚ä½™
    let remainder = 43 % 5;

    println!("sum = {}, difference = {}, product = {}, quotient = {}, remainder = {}", sum, difference, product, quotient, remainder);

    //èµ‹å€¼æ–¹æ³•
    //ç¼–è¯‘å™¨ä¼šæ ¹æ®å€¼è‡ªåŠ¨æ¨æ–­å˜é‡ç±»å‹
    let _a = 20;
    //æ˜¾å¼æŒ‡å®šç±»å‹
    let _a: i32 = 20;
    //åç¼€æŒ‡å®šç±»å‹
    let _a = 20i32;
    let _a = 20_i32;
    //åŒæ ·ç±»å‹çš„å˜é‡æ‰å¯ä»¥è¿ç®—

    //å¯¹äºè¾ƒé•¿çš„æ•°å­—ï¼Œå¯ä»¥ä½¿ç”¨ä¸‹åˆ’çº¿æ¥æé«˜å¯è¯»æ€§
    let a = 1_000_000;
    println!("a = {}", a);

    // å®šä¹‰ä¸€ä¸ªf32æ•°ç»„ï¼Œå…¶ä¸­42.0ä¼šè‡ªåŠ¨è¢«æ¨å¯¼ä¸ºf32ç±»å‹
    let forty_twos = [
        42.0,
        42f32,
        42.0_f32,
    ];
    // æ‰“å°æ•°ç»„ä¸­ç¬¬ä¸€ä¸ªå€¼ï¼Œå¹¶æ§åˆ¶å°æ•°ä½ä¸º2ä½
    println!("{:.2}", forty_twos[0]);

    //===============ä½è¿ç®—=====================
    let a: i32 = 2; // äºŒè¿›åˆ¶ 0000 0010
    let b: i32 = 3; // äºŒè¿›åˆ¶ 0000 0011
    println!("a & b = {}", a & b); // 0000 0010
    println!("a | b = {}", a | b); // 0000 0011
    println!("a ^ b = {}", a ^ b); // 0000 0001
    println!("!a = {}", !a); // 1111 1101
    println!("a << 1 = {}", a << 1); // 0000 0100
    println!("a >> 1 = {}", a >> 1); // 0000 0001

    //===============åºåˆ—=====================
    // rustæä¾›äº†ä¸€ç§ç®€ä»‹çš„æ–¹å¼ ç”Ÿæˆè¿ç»­çš„æ•°å­—åºåˆ—
    // .. ç”Ÿæˆä¸€ä¸ªå·¦é—­å³å¼€çš„åŒºé—´
    for i in 0..5 {
        println!("i = {}", i);
    }
    // ..= ç”Ÿæˆä¸€ä¸ªå·¦é—­å³é—­çš„åŒºé—´
    for i in 5..=10 {
        println!("i = {}", i);
    }
    //åºåˆ—åªå…è®¸ç”¨äºæ•´æ•°æˆ–å­—ç¬¦ç±»å‹ å› ä¸ºä»–ä»¬å¯ä»¥è¿ç»­
    for c in 'a'..='z' {
        print!("{}  ", c);
    }
    //ä½¿ç”¨aså®Œæˆç±»å‹è½¬æ¢
    for i in 0..5 {
        println!("i = {:.2}", i as f32);
    }

    //æœ‰ç†æ•°å’Œå¤æ•° æœ‰ç†æ•°å’Œå¤æ•°æœªåŒ…å«åœ¨æ ‡å‡†åº“ä¸­ï¼Œéœ€è¦å¼•å…¥ç¬¬ä¸‰æ–¹åº“

    let a = Complex { re: 1.0, im: 2.0 };
    let b = Complex::new(3.0, 4.0);
    let result = a + b;
    println!("result = {}", result);

    //rustä¸­çš„å­—ç¬¦ç±»å‹
    let c = 'å¼ '; //å•ä¸ªæ±‰å­—
    let emoji = 'ğŸ˜»'; //emojiè¡¨æƒ…
    let japanese = 'ã®'; //æ—¥æ–‡
    println!("c = {}, emoji = {}, japanese = {}", c, emoji, japanese);
    //rustä¸­çš„å­—ç¬¦ç±»å‹æ˜¯32ä½çš„ï¼Œå¯ä»¥å­˜å‚¨ä»»æ„çš„unicodeå­—ç¬¦
    println!("å­—ç¬¦'å¼ 'å ç”¨äº†{}ä¸ªå­—èŠ‚", std::mem::size_of_val(&c));

    //====================å¸ƒå°”ç±»å‹====================
    let _b = true;
    let b: bool = false;
    if !b { println!("b is {}", b) }

    //====================å•å…ƒ====================
    //å•å…ƒç±»å‹()ï¼Œä¹Ÿè¢«ç§°ä¸ºunitç±»å‹ï¼Œå®ƒåªæœ‰ä¸€ä¸ªå€¼ï¼Œä¹Ÿå°±æ˜¯()ï¼Œå®ƒåœ¨å‡½æ•°æ²¡æœ‰è¿”å›å€¼æ—¶ä½¿ç”¨
    //å¯ä»¥ç”¨ () ä½œä¸º map çš„å€¼ï¼Œè¡¨ç¤ºæˆ‘ä»¬ä¸å…³æ³¨å…·ä½“çš„å€¼ï¼Œåªå…³æ³¨ keyã€‚ è¿™ç§ç”¨æ³•å’Œ Go è¯­è¨€çš„ struct{} ç±»ä¼¼ï¼Œå¯ä»¥ä½œä¸ºä¸€ä¸ªå€¼ç”¨æ¥å ä½ï¼Œä½†æ˜¯å®Œå…¨ä¸å ç”¨ä»»ä½•å†…å­˜ã€‚

    //=======================è¯­å¥å’Œè¡¨è¾¾å¼=======================
    // å‡½æ•°
    fn add_with_extra(a: i32, b: i32) -> i32 {
        // è¯­å¥ä¼šæ‰§è¡Œä¸€äº›æ“ä½œï¼Œä½†æ˜¯ä¸è¿”å›å€¼
        let a = a + 1; //è¯­å¥
        let b = b + 1; //è¯­å¥
        // è¡¨è¾¾å¼ä¼šè¿”å›ä¸€äº›å€¼
        a + b //è¡¨è¾¾å¼
    }
    println!("add_with_extra(1, 2) = {}", add_with_extra(1, 2));
    //è¡¨è¾¾å¼ä¸èƒ½åŒ…å«åˆ†å· åœ¨è¡¨è¾¾å¼ååŠ ä¸Šåˆ†å·å°±ä¼šå˜æˆä¸€æ¡è¯­å¥ ä¸ä¼šè¿”å›å€¼
    //å¦‚æœè¡¨è¾¾å¼ä¸è¿”å›ä»»ä½•å€¼ï¼Œä¼šéšå¼è¿”å›ä¸€ä¸ªå•å…ƒç±»å‹çš„å€¼()
    // ifè¯­å¥å—ä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ å¯ä»¥ç”¨äºèµ‹å€¼ ç±»ä¼¼ä¸‰å…ƒè¡¨è¾¾å¼
    let a = 1;
    let b = if a % 2 == 1 { "odd" } else { "even" };
    println!("b = {}", b);

    //=======================å‡½æ•°=======================
    //å‡½æ•°çš„å‚æ•°å¿…é¡»å£°æ˜ç±»å‹,å‡½æ•°åå’Œå‚æ•°åå¿…é¡»ä½¿ç”¨snake_caseé£æ ¼,
    fn add_two(a: i32, b: i32) -> i32 {
        a + b
    }
    println!("add_two(1,2) = {}", add_two(1, 2));
    //å‡½æ•°ä¹Ÿæ˜¯è¡¨è¾¾å¼,å¯ä»¥æŠŠå‡½æ•°çš„è¡¨è¾¾å¼ç›´æ¥èµ‹å€¼ç»™å˜é‡
    fn plus_five(a: i32) -> i32 {
        a + 5
    }
    let f = plus_five(1);
    println!("f = {}", f);

    //å‘æ•£å‡½æ•° diverging function ä¸€èˆ¬ç”¨äºpanic ç”¨!ä½œå‡½æ•°è¿”å›ç±»å‹çš„æ—¶å€™ï¼Œè¡¨ç¤ºè¿™ä¸ªå‡½æ•°æ°¸è¿œä¸ä¼šè¿”å›
    fn _diverges() -> ! {
        panic!("This function never returns!");
    }
    //è¿˜æœ‰å¦ä¸€ç§å‘æ•£å‡½æ•°ï¼Œå°±æ˜¯ loop å¾ªç¯ï¼Œå®ƒæ°¸è¿œä¸ä¼šç»“æŸ
    fn _diverges2() -> ! {
        loop {}
    }

    //++++++++++++++++++++++++++++++++++++++++++++++++++++++æ‰€æœ‰æƒå’Œå€Ÿç”¨+++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //=======================æ‰€æœ‰æƒ=======================
    //æ‰€æœ‰æƒæ˜¯rustçš„ä¸€ä¸ªæ ¸å¿ƒæ¦‚å¿µï¼Œå®ƒæ˜¯ä¸€ç§å†…å­˜ç®¡ç†æœºåˆ¶ï¼Œå®ƒå¯ä»¥ä¿è¯å†…å­˜å®‰å…¨ï¼ŒåŒæ—¶ä¹Ÿä¸éœ€è¦åƒåœ¾å›æ”¶æœºåˆ¶
    //å˜é‡ä½œç”¨åŸŸ Rustä¸­æ¯ä¸ªå€¼éƒ½è¢«ä¸€ä¸ªå˜é‡æ‰€æ‹¥æœ‰ï¼Œå½“å˜é‡ç¦»å¼€ä½œç”¨åŸŸï¼Œè¿™ä¸ªå€¼å°±è¢«ä¸¢å¼ƒäº†
    {
        let s = "hello"; //sè¿›å…¥ä½œç”¨åŸŸ
        println!("{}", s);
    }//sç¦»å¼€ä½œç”¨åŸŸï¼Œè¢«ä¸¢å¼ƒ

    let _s = "hello"; //å­—ç¬¦ä¸²å­—é¢é‡ ä¸å¯å˜ ä¿å­˜åœ¨æ ˆä¸Š
    let mut s_string = String::from("hello"); //å­—ç¬¦ä¸²å¯¹è±¡ å¯å˜
    s_string.push_str(", world!"); //push_str() åœ¨å­—ç¬¦ä¸²åè¿½åŠ å­—é¢é‡
    println!("{}", s_string);

    //è½¬ç§»æ‰€æœ‰æƒ
    let x = 5;
    let y = x; //xçš„å€¼è¢«å¤åˆ¶åˆ°yï¼Œå› ä¸ºi32æ˜¯åŸºæœ¬ç±»å‹ï¼Œæ‰€ä»¥xå’Œyéƒ½æ˜¯5 è¿™é‡Œæ²¡æœ‰å‘ç”Ÿæ‰€æœ‰æƒè½¬ç§» å› ä¸ºi32æ˜¯Copyç±»å‹(æ•´æ•°ç±»å‹ï¼Œå›ºå®šå¤§å°çš„ç®€å•å€¼ éƒ½è¢«å­˜åœ¨æ ˆä¸Š)
    println!("x = {}, y = {}", x, y);

    let s1 = String::from("hello");
    let _s2 = s1;
    //s1çš„å€¼è¢«å¤åˆ¶åˆ°s2ï¼Œä½†æ˜¯s1çš„å€¼æ˜¯æŒ‡å‘å †ä¸Šçš„å†…å­˜åœ°å€ï¼Œæ‰€ä»¥s1å’Œs2éƒ½æŒ‡å‘äº†åŒä¸€å—å†…å­˜åœ°å€
    //è¿™é‡Œå‘ç”Ÿäº†æ‰€æœ‰æƒè½¬ç§»ï¼Œs1å¤±æ•ˆäº†ï¼Œä¸èƒ½å†ä½¿ç”¨,å› ä¸ºå‡è®¾è¿™é‡Œæ²¡æœ‰å‘ç”Ÿæ‰€æœ‰æƒè½¬ç§» s1å’Œs2éƒ½æœ‰æ„ä¹‰ï¼ŒæŒ‡å‘äº†åŒä¸€å—å†…å­˜åœ°å€ï¼Œ
    //é‚£ä¹ˆå½“s1å’Œs2éƒ½ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå°±ä¼šå‘ç”Ÿä¸¤æ¬¡é‡Šæ”¾å†…å­˜çš„æ“ä½œï¼Œè¿™å°±æ˜¯æ‰€è°“çš„double freeï¼Œè¿™æ˜¯ä¸€ç§å†…å­˜å®‰å…¨é—®é¢˜ï¼Œrustç¼–è¯‘å™¨ä¼šé˜»æ­¢è¿™ç§æƒ…å†µçš„å‘ç”Ÿ
    //println!("s1 = {}, s2 = {}",s1,s2);
    /*
        //è¿™é‡Œä¼šæŠ¥é”™ï¼Œå› ä¸ºs1å·²ç»å¤±æ•ˆäº†
        255 |     let s1 = String::from("hello");
            |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
        256 |     let s2 = s1;
            |              -- value moved here
        ...
        260 |     println!("s1 = {}, s2 = {}",s1,s2);
            |                                 ^^ value borrowed here after move
    */
    let x: &str = "hello";
    let y = x;
    //è¿™é‡Œxåªå­˜å‚¨äº†å¯¹helloçš„å¼•ç”¨ï¼Œèµ‹å€¼ç»™yçš„è¿‡ç¨‹å¹¶æ²¡æœ‰å‘ç”Ÿæ‰€æœ‰æƒè½¬ç§»ï¼Œå› ä¸º&stræ˜¯ä¸€ä¸ªæŒ‡å‘å­—ç¬¦ä¸²å­—é¢é‡çš„å¼•ç”¨ï¼Œå®ƒæ˜¯ä¸€ä¸ªå›ºå®šå¤§å°çš„å€¼ï¼Œå­˜å‚¨åœ¨æ ˆä¸Š
    println!("x = {}, y = {}", x, y);

    //=====æ·±æ‹·è´=======
    //Rustä¸ä¼šè‡ªåŠ¨åˆ›å»ºæ•°æ®çš„æ·±æ‹·è´
    let s1 = String::from("hello");
    let s2 = s1.clone(); // æ˜¾å¼è°ƒç”¨cloneæ–¹æ³• å®Œæ•´æ‹·è´s1åœ¨å †ä¸Šçš„æ•°æ®
    println!("s1 = {}, s2 = {}", s1, s2);
    //NOTICE cloneä¼šå¯¹æ‰€æœ‰æ•°æ®è¿›è¡Œæ·±æ‹·è´ï¼Œè¿™ä¼šæ¶ˆè€—å¾ˆå¤šèµ„æºï¼Œæ‰€ä»¥åœ¨rustä¸­ï¼Œæ·±æ‹·è´æ˜¯æ˜¾å¼çš„ï¼Œè€Œä¸æ˜¯éšå¼çš„

    //=====æµ…æ‹·è´=======
    //æµ…æ‹·è´åªå‘ç”Ÿåœ¨æ ˆä¸Š å¯Copyçš„ç±»å‹æœ‰ï¼šæ•´æ•°ç±»å‹ã€æµ®ç‚¹ç±»å‹ã€å¸ƒå°”ç±»å‹ã€å­—ç¬¦ç±»å‹ã€å…ƒç»„ç±»å‹(å…¶ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯Copyç±»å‹)

    //=====æ‰€æœ‰æƒå’Œå‡½æ•°=======
    //æ‰€æœ‰æƒä¹Ÿä¼šå‘ç”Ÿåœ¨å‡½æ•°è°ƒç”¨ä¸­ ä¾‹å¦‚
    let s = String::from("hello");
    takes_ownership(s); //sçš„å€¼è¢«ç§»åŠ¨åˆ°å‡½æ•°é‡Œ
    //println!("{}",s); //è¿™é‡Œä¼šæŠ¥é”™ï¼Œå› ä¸ºså·²ç»å¤±æ•ˆäº†
    let x = 5;
    makes_copy(x); //xçš„å€¼è¢«å¤åˆ¶åˆ°å‡½æ•°é‡Œ
    println!("{}", x); //è¿™é‡Œä¸ä¼šæŠ¥é”™ï¼Œå› ä¸ºxæ˜¯Copyç±»å‹ï¼Œæ‰€ä»¥xçš„å€¼æ²¡æœ‰å‘ç”Ÿæ‰€æœ‰æƒè½¬ç§»ï¼Œxä»ç„¶æœ‰æ•ˆ

    //=====è¿”å›å€¼å’Œä½œç”¨åŸŸ=======
    //è¿”å›å€¼ä¹Ÿä¼šå‘ç”Ÿæ‰€æœ‰æƒè½¬ç§»

    let s1 = gives_ownership(); // gives_ownership å°†è¿”å›å€¼ç§»åŠ¨ç»™ s1
    let s2 = String::from("hello"); // s2 è¿›å…¥ä½œç”¨åŸŸ
    let s3 = takes_and_gives_back(s2); // s2 è¢«ç§»åŠ¨åˆ° takes_and_gives_back ä¸­,å®ƒä¹Ÿå°†è¿”å›å€¼ç§»åŠ¨ç»™ s3
    println!("s1 = {}, s3 = {}", s1, s3); //è¿™é‡Œå¦‚æœå°è¯•æ‰“å°s2ä¼šæŠ¥é”™ï¼Œå› ä¸ºs2å·²ç»å¤±æ•ˆäº†

    //=====å¼•ç”¨å’Œå€Ÿç”¨=======

    // å¼•ç”¨å’Œè§£å¼•ç”¨
    let x = 5;
    let y = &x;
    println!("x = {}, y = {}", x, *y); //è§£å¼•ç”¨
    //å¼•ç”¨å’Œè§£å¼•ç”¨æ˜¯ä¸€å¯¹äº’é€†æ“ä½œï¼Œå¼•ç”¨æ˜¯æŒ‡å‘æŸä¸ªå€¼çš„æŒ‡é’ˆï¼Œè§£å¼•ç”¨æ˜¯è·å–æŒ‡é’ˆæŒ‡å‘çš„å€¼
    //ä¸å¯å˜å¼•ç”¨
    let s1 = String::from("hello");
    let len = calculate_length(&s1); //ä¼ é€’s1çš„å¼•ç”¨ ä½†æ˜¯calculate_lengthå‡½æ•°å¹¶ä¸æ‹¥æœ‰s1çš„æ‰€æœ‰æƒ
    println!("The length of '{}' is {}.", s1, len); //æ‰€ä»¥è¿™é‡Œæ‰“å°s1æ˜¯æ²¡æœ‰é—®é¢˜çš„
    //å¯å˜å¼•ç”¨ å°è¯•ä¿®æ”¹å¼•ç”¨å˜é‡
    let mut s2 = String::from("hello");
    change(&mut s2); //ä¼ é€’s2çš„å¯å˜å¼•ç”¨
    println!("s2 = {}", s2);
    //å¯å˜å¼•ç”¨æœ‰ä¸€ä¸ªå¾ˆå¤§çš„é™åˆ¶ï¼Œå°±æ˜¯åœ¨ç‰¹å®šä½œç”¨åŸŸä¸­çš„ç‰¹å®šæ•°æ®åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œè¿™æ ·åšçš„ç›®çš„æ˜¯ä¸ºäº†é˜²æ­¢æ•°æ®ç«äº‰
    //æ•°æ®ç«äº‰æ˜¯æŒ‡ä¸¤ä¸ªæˆ–æ›´å¤šæŒ‡é’ˆåŒæ—¶è®¿é—®åŒä¸€å—æ•°æ®ï¼Œè‡³å°‘æœ‰ä¸€ä¸ªæŒ‡é’ˆç”¨äºå†™å…¥æ•°æ®ï¼Œä¸”æ²¡æœ‰åŒæ­¥æ•°æ®è®¿é—®çš„æœºåˆ¶
    let mut s = String::from("hello");
    let r1 = &mut s;
    println!("r1 = {}", r1); //è¿™é‡Œæ‰“å°r1 ä¸‹é¢çš„å€Ÿç”¨å°±ä¸ä¼šè§¦å‘borrow checker å³åœ¨ç¬¬ä¸€æ¬¡å€Ÿç”¨åˆ°æœ€åä¸€æ¬¡ä½¿ç”¨ä¹‹é—´ï¼Œä¸èƒ½æœ‰ä»»ä½•ä¿®æ”¹å€Ÿç”¨å˜é‡çš„æ“ä½œ
    let r2 = &mut s; // å¦‚æœä¸Šé¢çš„æ‰“å°è¯­å¥ä¸æ‰§è¡Œï¼Œè¿™é‡Œä¼šæŠ¥é”™ï¼Œå› ä¸ºså·²ç»è¢«r1å€Ÿç”¨äº†ï¼Œä¸”r1æ²¡æœ‰å®Œæˆæœ€åä¸€æ¬¡ä½¿ç”¨,æ‰€ä»¥ä¸èƒ½å†è¢«r2å€Ÿç”¨ åœ¨ç¼–è¯‘æœŸå°±é¿å…äº†æ•°æ®ç«äº‰
    //println!("r1 = {}, r2 = {}",r1,r2);
    println!("r2 = {}", r2);
    //println!("r1 = {}",r1);

    //NOTICE {}å ä½ç¬¦ä¼šè‡ªåŠ¨è§£å¼•ç”¨ å¯ä»¥å¸®æˆ‘ä»¬è§£å†³ä¸€äº›ç¼–è¯‘é”™è¯¯
    let mut s = String::from("hello");
    {
        let _r1 = &mut s;
    } // r1 åœ¨è¿™é‡Œç¦»å¼€äº†ä½œç”¨åŸŸ æ‰€ä»¥æˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªæ–°çš„å¼•ç”¨

    let r2 = &mut s;
    println!("r2 = {}", r2);

    //å¯å˜å¼•ç”¨å’Œä¸å¯å˜å¼•ç”¨ä¸èƒ½åŒæ—¶å­˜åœ¨
    let mut _s = String::from("hello");
    let r1 = &s; //ä¸å¯å˜å¼•ç”¨
    let r2 = &s; //ä¸å¯å˜å¼•ç”¨
    println!("r1 = {}, r2 = {}", r1, r2); //è¿™é‡ŒåŠ ä¸€å¥ ä¸‹é¢çš„å¯å˜å¼•ç”¨å°±ä¸ä¼šæŠ¥é”™
    //let r3 = &mut s; //å¯å˜å¼•ç”¨
    //println!("{}, {}, and {}", r1, r2, r3); //è¿™é‡Œä¼šæŠ¥é”™ï¼Œå› ä¸ºr1å’Œr2æ˜¯ä¸å¯å˜å¼•ç”¨ï¼Œr3æ˜¯å¯å˜å¼•ç”¨ï¼Œå¯å˜å¼•ç”¨å’Œä¸å¯å˜å¼•ç”¨ä¸èƒ½åŒæ—¶å­˜åœ¨
    assert_eq!(r1, r2); //è¿™é‡Œå¯ä»¥ä½¿ç”¨æ–­è¨€ï¼Œå› ä¸ºr1å’Œr2æ˜¯ä¸å¯å˜å¼•ç”¨ï¼Œæ‰€ä»¥ä¸ä¼šå‘ç”Ÿæ•°æ®ç«äº‰

    //NOTICE!!! å¼•ç”¨çš„ä½œç”¨åŸŸæ˜¯ä»å£°æ˜å¼€å§‹ä¸€ç›´æŒç»­åˆ°æœ€åä¸€æ¬¡ä½¿ç”¨ä¸ºæ­¢ å’Œå˜é‡æœ‰æ‰€ä¸åŒ å˜é‡çš„ä½œç”¨åŸŸæ˜¯ä»å£°æ˜å¼€å§‹ä¸€ç›´æŒç»­åˆ°å½“å‰ä½œç”¨åŸŸç»“æŸä¸ºæ­¢(å³åˆ°è¾¾'}'ä¸ºæ­¢)

    //æ‚¬å‚å¼•ç”¨
    //æ‚¬å‚å¼•ç”¨æ˜¯æŒ‡æŒ‡å‘äº†å·²ç»è¢«é‡Šæ”¾çš„å†…å­˜çš„æŒ‡é’ˆï¼Œrustç¼–è¯‘å™¨ä¼šé˜»æ­¢è¿™ç§æƒ…å†µçš„å‘ç”Ÿ å³åœ¨å¼•ç”¨ç»“æŸå‰ä¸å…è®¸å˜é‡è¢«é‡Šæ”¾
    //let reference_to_nothing = dangle(); //è¿™é‡Œä¼šæŠ¥é”™ï¼Œå› ä¸ºdangleå‡½æ•°è¿”å›çš„æ˜¯ä¸€ä¸ªæŒ‡å‘å †ä¸Šæ•°æ®çš„å¼•ç”¨ï¼Œä½†æ˜¯dangleå‡½æ•°ç»“æŸåï¼Œè¿™ä¸ªæ•°æ®å°±è¢«é‡Šæ”¾äº†ï¼Œæ‰€ä»¥è¿™é‡Œä¼šæŠ¥é”™

    //==================================================================å¤åˆç±»å‹==================================================================
    //=======================å­—ç¬¦ä¸²ä¸åˆ‡ç‰‡=======================
    //å­—ç¬¦ä¸²å­—é¢é‡
    let s = "hello world";
    //å­—ç¬¦ä¸²å¯¹è±¡
    let _s1 = String::from("hello world");
    //å­—ç¬¦ä¸²åˆ‡ç‰‡
    let hello = &s[0..5]; //btw è¿™ç§å†™æ³•å«åºåˆ— è¯¦è§ main.rs: 154
    let world = &s[6..11];
    println!("hello = {}, world = {}", hello, world);
    //ç±»ä¼¼golangåˆ‡ç‰‡æ“ä½œ ä»ç´¢å¼•0å¼€å§‹æˆªå–å’Œæˆªå–åˆ°æœ€åä¸€ä¸ªå…ƒç´ çš„å†™æ³•åˆ†åˆ«å¦‚ä¸‹
    let hello = &s[..5];
    let world = &s[6..];
    println!("hello = {}, world = {}", hello, world);
    //NOTICE å¯¹äºå­—ç¬¦ä¸²ä½¿ç”¨åˆ‡ç‰‡è¯­æ³•æ—¶ åˆ‡ç‰‡çš„ç´¢å¼•å¿…é¡»æ˜¯æœ‰æ•ˆçš„å­—ç¬¦ç´¢å¼• å¦‚æœä½¿ç”¨æ— æ•ˆçš„å­—ç¬¦ç´¢å¼•ä¼šå¯¼è‡´panic æ¯”å¦‚æ±‰å­—åœ¨UTF-8ç¼–ç ä¸­å 3ä¸ªå­—èŠ‚ æˆªå–&s[2..]ä¼španic
    let _s = "ä½ å¥½ä¸–ç•Œ";
    //let cut = &s[2..]; //è¿™å¥æŠ¥é”™ï¼španicked at 'byte index 2 is not a char boundary; it is inside 'ä½ ' (bytes 0..3) of `ä½ å¥½ä¸–ç•Œ`'
    //println!("cut = {}",cut);
    let mut s = String::from("hello world");
    let word = first_word(&s);
    println!("word = {}", word); //è¿™å¥æ‰“å¼€ ä¸‹é¢ä¸€å¥å°±ä¸ä¼šæŠ¥é”™ å› ä¸ºä¸å¯å˜å€Ÿç”¨å·²ç»ä½¿ç”¨è¿‡äº†
    //s.clear(); //è¿™å¥çš„å‚æ•°æ˜¯å¯¹è‡ªèº«çš„å¯å˜å€Ÿç”¨ ç„¶è€Œwordæ˜¯å¯¹sçš„ä¸å¯å˜å€Ÿç”¨ æ‰€ä»¥è¿™é‡Œä¼šæŠ¥é”™ å‚è§main.rs: 337

    //=========å…¶å®ƒåˆ‡ç‰‡========
    let a = [1, 2, 3, 4, 5];
    let slice = &a[1..3];
    assert_eq!(slice, &[2, 3]);

    //=================å­—ç¬¦ä¸²=================
    //Rustä¸­çš„å­—ç¬¦æ˜¯Unicodeç±»å‹çš„ æ¯ä¸ªå­—ç¬¦å æ®4ä¸ªå­—èŠ‚ï¼Œä½†å­—ç¬¦ä¸²æ˜¯UTF-8ç¼–ç ï¼Œæ‰€ä»¥ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­çš„æ¯ä¸ªå­—ç¬¦æ‰€å çš„å­—èŠ‚æ•°æ˜¯å˜åŒ–çš„ï¼ˆ1-4ï¼‰
    //Rustè¯­è¨€çº§åˆ«çš„å­—ç¬¦ä¸²ç±»å‹å°±æ˜¯å­—ç¬¦ä¸²å­—é¢é‡ï¼Œå®ƒæ˜¯ä¸€ä¸ªä¸å¯å˜çš„å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼Œå®ƒçš„ç±»å‹æ˜¯&str åœ¨æ ‡å‡†åº“é‡Œè¿˜æœ‰ä¸€ä¸ªStringç±»å‹ï¼Œå®ƒæ˜¯ä¸€ä¸ªå¯å˜çš„å­—ç¬¦ä¸²å¯¹è±¡
    //stræ˜¯ç¡¬ç¼–ç è¿›å¯æ‰§è¡Œæ–‡ä»¶çš„ï¼Œæ— æ³•è¢«ä¿®æ”¹ Stringæ˜¯ä¸€ä¸ªå¯å˜ä¸”å…·æœ‰æ‰€æœ‰æƒçš„UTF-8ç¼–ç å­—ç¬¦ä¸²

    //Stringå’Œ&strè½¬æ¢ TODO deref éšå¼å¼ºåˆ¶è½¬æ¢
    let s = String::from("hello world");
    let s = &s[..]; //è½¬æ¢ä¸ºå­—ç¬¦ä¸²åˆ‡ç‰‡
    let s = s.to_string(); //è½¬æ¢ä¸ºå­—ç¬¦ä¸²å¯¹è±¡
    let s = s.as_str(); //è½¬æ¢ä¸ºå­—ç¬¦ä¸²åˆ‡ç‰‡
    println!("s = {}", s);
    //å­—ç¬¦ä¸²ç´¢å¼•
    let s = String::from("hello");
    //let h = s[0]; //è¿™é‡Œä¼šæŠ¥é”™ `String` cannot be indexed by `{integer}`
    /*
        å­—ç¬¦ä¸²æºç ï¼š
        pub struct String {
            vec: Vec<u8>,
        }
        åº•å±‚å®é™…ä¸Šæ˜¯ä¸€ä¸ªVec<u8>ï¼Œä¸åŒç±»å‹çš„æ–‡å­—åœ¨UTF-8ä¸‹é•¿åº¦ä¸åŒ æ‰€ä»¥é€šè¿‡ç´¢å¼•å–æ²¡æœ‰æ„ä¹‰ ä¸”å¦‚æœè¦ä¿è¯ç´¢å¼•è¯»O(1)çš„æ—¶é—´å¤æ‚åº¦
        åˆä¸å…è®¸éå†åˆ°åˆæ³•å­—ç¬¦çš„ç»“å°¾ï¼Œæ‰€ä»¥å¹²è„†ç¦æ­¢è¿™æ ·åš
    */
    let h = s.index(0..1);
    println!("h = {}", h);

    //å­—ç¬¦ä¸²æ“ä½œ
    let mut s = String::from("hello"); //å¯æ“ä½œçš„å­—ç¬¦ä¸²å¿…é¡»æ˜¯å¯å˜çš„
    //è¿½åŠ 
    s.push_str(" world"); //è¿½åŠ å­—ç¬¦ä¸²
    s.push('!');//è¿½åŠ å­—ç¬¦
    println!("s = {}", s);
    //æ’å…¥
    s.insert_str(0, "hello Rust"); //åœ¨ç´¢å¼•0å¤„æ’å…¥å­—ç¬¦ä¸²
    s.insert(10, '!'); //åœ¨ç´¢å¼•10å¤„æ’å…¥å­—ç¬¦
    println!("s = {}", s);
    //æ›¿æ¢
    let mut s1 = s.replace("rust", "RUST");//é€‚ç”¨äºStringå’Œ&str è¿”å›çš„æ˜¯ä¸€ä¸ªæ–°å­—ç¬¦ä¸² åŸå­—ç¬¦ä¸²ä¸å¿…mut
    let mut s2 = s1.replacen("RUST", "rust", 1); //é€‚ç”¨äºStringå’Œ&str è¿”å›çš„æ˜¯ä¸€ä¸ªæ–°å­—ç¬¦ä¸² åŸå­—ç¬¦ä¸²ä¸å¿…mut åªæ›¿æ¢ç¬¬ä¸€ä¸ªç›®æ ‡å€¼
    s2.replace_range(0..5, "HELLO"); //é€‚ç”¨äºString ç›´æ¥æ“ä½œåŸå­—ç¬¦ä¸² å¿…é¡»mut
    println!("s = {:?}", s2);
    //åˆ é™¤
    let p1 = s.pop();//åˆ é™¤æœ€åä¸€ä¸ªå­—ç¬¦å¹¶è¿”å›
    println!("p1 = {:?}", p1);
    let mut s = String::from("ä½ å¥½ä½ å¥½");
    s.remove(0);//åˆ é™¤ç¬¬ä¸€ä¸ªå­—ç¬¦ // removeçš„å‚æ•°å¦‚æœä¸æ˜¯åˆæ³•å­—ç¬¦çš„è¾¹ç•Œä¼šæŠ¥é”™
    println!("s = {}", s);
    //s.remove(2); //panic ç´¢å¼•2æ˜¯éæ³•è¾¹ç•Œ
    s.truncate(3);//åˆ é™¤ç´¢å¼•3ä¹‹åçš„æ‰€æœ‰å­—ç¬¦
    println!("s = {}", s);
    s.clear();//æ¸…ç©ºå­—ç¬¦ä¸²
    dbg!(s);
    //è¿æ¥
    let s1 = String::from("hello ");
    let s2 = String::from("world");
    let s3 = s1 + &s2; //s2ä¼šè‡ªåŠ¨è§£å¼•ç”¨ä¸º&strç±»å‹ s1çš„æ‰€æœ‰æƒè¢«è½¬ç§» ä¸èƒ½å†æ‰“å°s1 â€˜+â€™æ˜¯add() s1çš„æ‰€æœ‰æƒè¢«è½¬ç§»åˆ°add()é‡Œäº†
    let mut s3 = s3 + "!";
    s3 += "!";
    println!("s3 = {}", s3);
    // !formatæ–¹å¼
    let s1 = String::from("hello ");
    let s2 = String::from("world");
    let s3 = format!("{}{}{}", s1, s2, "!"); //format!å®ä¼šè¿”å›ä¸€ä¸ªStringå¯¹è±¡
    println!("s3 = {}", s3);
    //å­—ç¬¦ä¸²è½¬ä¹‰ï¼šå¯ä»¥é€šè¿‡'\'è¾“å‡º ASCII å’Œ Unicode å­—ç¬¦
    let s = "hello world \x52\x75\x73\x74\n";
    println!("s = {}", s);
    // \u å¯ä»¥è¾“å‡ºä¸€ä¸ª unicode å­—ç¬¦
    let unicode_codepoint = "\u{211D}";
    let character_name = "\"DOUBLE-STRUCK CAPITAL R\"";

    println!(
        "Unicode character {} (U+211D) is called {}",
        unicode_codepoint, character_name
    );

    // æ¢è¡Œäº†ä¹Ÿä¼šä¿æŒä¹‹å‰çš„å­—ç¬¦ä¸²æ ¼å¼
    // ä½¿ç”¨\å¿½ç•¥æ¢è¡Œç¬¦
    let long_string = "String literals
                        can span multiple lines.
                        The linebreak and indentation here ->\
                        <- can be escaped too!";
    println!("{}", long_string);

    println!("{}", "hello \\x52\\x75\\x73\\x74");
    // åŸå§‹å­—ç¬¦ä¸² ä¸è½¬ä¹‰
    let raw_str = r"Escapes don't work here: \x3F \u{211D}";
    println!("{}", raw_str);

    // å¦‚æœå­—ç¬¦ä¸²åŒ…å«åŒå¼•å·ï¼Œå¯ä»¥åœ¨å¼€å¤´å’Œç»“å°¾åŠ  #
    let quotes = r#"And then I said: "There is no escape!""#;
    println!("{}", quotes);

    // å¦‚æœè¿˜æ˜¯æœ‰æ­§ä¹‰ï¼Œå¯ä»¥ç»§ç»­å¢åŠ ï¼Œæ²¡æœ‰é™åˆ¶
    let longer_delimiter = r###"A string with "# in it. And even "##!"###;
    println!("{}", longer_delimiter);

    //=======================================å…ƒç»„=======================================
    let tup: (i32, f64, u8) = (500, 6.4, 1);
    //å¯ä»¥ç”¨æ¨¡å¼åŒ¹é…æˆ–è€….ç´¢å¼•çš„æ–¹å¼è·å–å…ƒç»„çš„å€¼
    let (x, y, z) = tup;
    println!("x = {}, y = {}, z = {}", x, y, z);
    println!("tup.0 = {}, tup.1 = {}, tup.2 = {}", tup.0, tup.1, tup.2);
    //å…ƒç»„å¯ä»¥ä½œä¸ºå‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼
    let s1 = String::from("hello");
    let (s2, len) = calculate_length2(s1);
    println!("s2 = {}, len = {}", s2, len);

    //=======================================ç»“æ„ä½“=======================================
    /*
        1.ç»“æ„ä½“æ˜¯ä¸€ç§è‡ªå®šä¹‰æ•°æ®ç±»å‹ï¼Œå®ƒå…è®¸ä½ å‘½åå’ŒåŒ…è£…å¤šä¸ªç›¸å…³çš„å€¼ï¼Œä»è€Œå½¢æˆä¸€ä¸ªæ›´åŠ æœ‰æ„ä¹‰çš„ç»„åˆ
        2.ç»“æ„ä½“çš„æ¯ä¸ªå€¼éƒ½æœ‰è‡ªå·±çš„ç±»å‹ï¼Œè¿™äº›ç±»å‹è¢«ç§°ä¸ºç»“æ„ä½“çš„å­—æ®µï¼Œå¹¶ä¸”å¯ä»¥ç‹¬ç«‹å‘½åå’ŒæŒ‡å®šç±»å‹
        3.åˆå§‹åŒ–å®ä¾‹æ—¶ï¼Œæ¯ä¸ªå­—æ®µéƒ½å¿…é¡»æœ‰å€¼ï¼Œå¦åˆ™ç¼–è¯‘å™¨ä¼šæŠ¥é”™
        4.é¡ºåºä¸å¿…å’Œå®šä¹‰æ—¶ä¸€è‡´
    */
    let mut u1 = User {
        username: String::from("å¼ ä¸‰"),
        email: String::from("xxx@example.com"),
        sign_in_count: 1,
        active: true,
    };
    u1.username = String::from("æå››"); // éœ€è¦å°†ç»“æ„ä½“å®ä¾‹å®šä¹‰ä¸ºå¯å˜ï¼Œæ‰èƒ½ä¿®æ”¹ç»“æ„ä½“çš„å­—æ®µ Rustä¸æ”¯æŒå°†ç»“æ„ä½“çš„æŸä¸ªå­—æ®µè®¾ç½®ä¸ºå¯å˜æˆ–ä¸å¯å˜
    println!("u1.username = {}", u1.username);
    let u2 = build_user(String::from("aaa@example.com"), String::from("ç‹äº”"));
    println!("u2.username = {}", u2.username);
    // åˆ©ç”¨å·²æœ‰çš„user1 åˆ›å»ºuser3
    let u3 = User {
        email: String::from("xxx@example.com"),
        ..u1
    }; // u3å’Œu1åªæœ‰emailå­—æ®µä¸åŒ æ‰€ä»¥å¯ä»¥ç”¨ ..u1 è¯­æ³•æ¥åˆ›å»ºu3 ..u1è¿™ç§å†™æ³•å¿…é¡»åœ¨ç»“æ„ä½“å°¾éƒ¨ä½¿ç”¨
    //usernameå­—æ®µå‘ç”Ÿäº†æ‰€æœ‰æƒè½¬ç§»
    println!("u3.username = {}", u3.username);

    //å…ƒç»„ç»“æ„ä½“ ç»“æ„ä½“éœ€è¦åç§°ï¼Œä½†æ˜¯ç»“æ„ä½“å­—æ®µä¸ä¸€å®šéœ€è¦
    struct Color(i32, i32, i32);
    struct Point(i32, i32, i32);
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
    println!("black = ({},{},{})", black.0, black.1, black.2);
    println!("origin = ({},{},{})", origin.0, origin.1, origin.2);

    //å•å…ƒç»“æ„ä½“
    struct Unit;
    let _unit = Unit;

    //=======================æšä¸¾=======================

    //æšä¸¾ç±»å‹æ˜¯ä¸€ä¸ªç±»å‹ï¼Œå®ƒä¼šåŒ…å«æ‰€æœ‰å¯èƒ½çš„æšä¸¾æˆå‘˜, è€Œæšä¸¾å€¼æ˜¯è¯¥ç±»å‹ä¸­çš„å…·ä½“æŸä¸ªæˆå‘˜çš„å®ä¾‹
    let four = IpAddrKind::V4;
    let _six = IpAddrKind::V6;
    print_IpAddrKind(&four);

    let info = IpInfo {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };
    print_IpInfo(info);
    // æšä¸¾æˆå‘˜å¯ä»¥åŒ…å«æ•°æ® è§PokerCard
    let clubs = PokerCard::Clubs(1);
    let spades = PokerCard::Spades(2);
    let diamonds = PokerCard::Diamonds(3);
    let hearts = PokerCard::Hearts(4);
    print_PokerCards(&[clubs, spades, diamonds, hearts]);

    //ä»»ä½•ç±»å‹çš„æ•°æ®éƒ½å¯ä»¥ä½œä¸ºæšä¸¾æˆå‘˜ ä¾‹å¦‚å­—ç¬¦ä¸²ã€æ•°å€¼ç”šè‡³ç»“æ„ä½“
    let m1 = Message::Quit;
    let m2 = Message::Move { x: 1, y: 2 };
    let m3 = Message::Write(String::from("hello"));
    let m4 = Message::ChangeColor(1, 2, 3);
    // ä¸Šè¿°çš„å››ä¸ªæšä¸¾æˆå‘˜éƒ½æœ‰ä¸åŒçš„ç±»å‹ å…¶å®å¯ä»¥ç”¨structæ¥å®ç° ç”¨æšä¸¾çš„å¥½å¤„æ˜¯å¯ä»¥å°†æ‰€æœ‰çš„ç±»å‹éƒ½æ”¾åœ¨ä¸€ä¸ªå‘½åç©ºé—´ä¸‹
    // ç»“åˆä¸Šè¿°åœºæ™¯ å¦‚æœä¸€ä¸ªå‡½æ•°çš„åŠŸèƒ½æ˜¯æ¥æ”¶å¹¶è½¬å‘Message ä½†æ˜¯å®ƒä¸å…³å¿ƒæ¶ˆæ¯ç±»å‹ å¦‚æœç”¨ç»“æ„ä½“çš„è¯ è¿™ä¸ªå‡½æ•°æ— æ³•æ¥å—4ä¸ªç±»å‹çš„ç»“æ„ä½“å‚æ•°
    send_Msg(m1);
    send_Msg(m2);
    send_Msg(m3);
    send_Msg(m4);
    //Optionæšä¸¾ ç”¨äºå¤„ç†ç©ºå€¼
    /*
        enum Option<T> {
            Some(T),
            None,
        }
    */
    //Option<T>æ˜¯ä¸€ä¸ªæ³›å‹æšä¸¾ï¼Œå®ƒæœ‰ä¸¤ä¸ªæˆå‘˜ï¼ŒSome(T)å’ŒNoneï¼ŒSome(T)è¡¨ç¤ºä¸€ä¸ªåŒ…å«äº†æŸä¸ªç±»å‹çš„å€¼çš„Optionæšä¸¾ï¼Œ
    // Noneè¡¨ç¤ºä¸€ä¸ªç©ºå€¼
    let some_number = Some(5);
    let some_string = Some("a string");
    let absent_number: Option<i32> = None;
    println!("some_number = {:?}, some_string = {:?}, absent_number = {:?}", some_number, some_string, absent_number);
    // ä½¿ç”¨Option<T>çš„å¥½å¤„æ˜¯å½“æˆ‘ä»¬æƒ³è¦ä½¿ç”¨Tçš„æ—¶å€™ å°±å¿…é¡»å¤„ç†Noneçš„æƒ…å†µ è¿™æ ·å¯ä»¥é¿å…ç©ºæŒ‡é’ˆå¼‚å¸¸ ç¡®ä¿æˆ‘ä»¬å¯¹æœ‰å¯èƒ½çš„ç©ºå€¼è¿›è¡Œå¤„ç†
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            None => None,
            Some(i) => Some(i + 1),
        }
    }
    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
    println!("five = {:?}, six = {:?}, none = {:?}", five, six, none);

    //åˆ‡ç‰‡ ä¸æ•°ç»„ä¸åŒï¼Œåˆ‡ç‰‡çš„é•¿åº¦åœ¨ç¼–è¯‘æœŸæ˜¯ä¸ç¡®å®šçš„ï¼Œæ‰€ä»¥åˆ‡ç‰‡æ˜¯ä¸€ä¸ªåŠ¨æ€çš„ç±»å‹
    let a: [i32; 5] = [1, 2, 3, 4, 5];
    let slice = &a[1..3];
    println!("slice = {:?}", slice);
    //åˆ›å»ºåˆ‡ç‰‡çš„ä»£ä»·å¾ˆå°ï¼Œå®ƒåªæ˜¯å¯¹åŸæ•°ç»„çš„å¼•ç”¨ï¼Œæ‰€ä»¥åˆ‡ç‰‡çš„å¤åˆ¶ä»£ä»·ä¹Ÿå¾ˆå°

    //========================================æµç¨‹æ§åˆ¶========================================
    //=======================ifè¡¨è¾¾å¼=======================
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };
    println!("number = {}", number); //æ¯ä¸ªåˆ†æ”¯é‡Œçš„è¿”å›å€¼ç±»å‹å¿…é¡»ä¸€è‡´
    //=======================å¾ªç¯=======================
    for i in 1..=5 {
        println!("i = {}", i);
    }
    //éå†é›†åˆç±»å‹çš„æ—¶å€™ å¾€å¾€è¦ä½¿ç”¨é›†åˆçš„å¼•ç”¨å½¢å¼ å¦‚æœä¸ä½¿ç”¨å¼•ç”¨å½¢å¼ è¿™ä¸ªé›†åˆçš„æ‰€æœ‰æƒä¼šè¢«è½¬ç§»åˆ°forè¯­å¥ä¸­ ç„¶åéšç€è¯­å¥æ‰§è¡Œå®Œæˆé‡Šæ”¾ åé¢æ²¡æ³•å†ç”¨è¿™ä¸ªé›†åˆäº†
    let mut a = [1, 2, 3, 4, 5];
    for i in &a {
        println!("i = {}", i);
    }
    // åœ¨forä¸­ä¿®æ”¹å…ƒç´ 
    for j in &mut a {
        *j += 1;
    }
    println!("a = {:?}", a);
    // åœ¨å¾ªç¯ä¸­è·å–ç´¢å¼•
    for (i, j) in a.iter().enumerate() {
        println!("i = {}, j = {}", i, j);
    }
    //continue
    for i in 1..5 {
        if i == 2 {
            continue;
        } else if i == 4 { break; }
        println!("i = {}", i);
    }
    //whileå¾ªç¯
    let mut i = 1;
    while i <= 5 {
        println!("i = {}", i);
        i += 1;
    }
    //loopå¾ªç¯ é…åˆifå’Œbreakå®ç°æ¡ä»¶å¾ªç¯
    let mut i = 1;
    loop {
        if i > 5 { break; }
        println!("i = {}", i);
        i += 1;
    }
    //NOTICE ä½¿ç”¨è¿­ä»£å™¨éå†æ•°ç»„ï¼ˆåˆ‡ç‰‡ï¼‰æ€§èƒ½ä¼šæ›´å¥½ å› ä¸ºé¿å…äº†æ¯æ¬¡çš„è¿è¡Œæ—¶ç´¢å¼•è¾¹ç•Œæ£€æŸ¥

    // breakå¯ä»¥å•ç‹¬ä½¿ç”¨ ä¹Ÿå¯ä»¥å¸¦ä¸€ä¸ªè¿”å›å€¼

    //==============================æ¨¡å¼åŒ¹é…==============================
    //matchè¡¨è¾¾å¼ ç±»ä¼¼golangçš„switch
    let number = 13;
    match number {
        1 => println!("one"),
        2 => println!("two"),
        3 => println!("three"),
        13 => println!("thirteen"),
        _ => println!("others"),
    }
    //matchè¡¨è¾¾å¼çš„æ¯ä¸ªåˆ†æ”¯éƒ½æ˜¯ä¸€ä¸ªæ¨¡å¼ï¼Œæ¨¡å¼å¯ä»¥æ˜¯å­—é¢é‡ã€å˜é‡ã€é€šé…ç¬¦ã€å ä½ç¬¦ã€æšä¸¾ã€ç»“æ„ä½“ã€å…ƒç»„ã€èŒƒå›´ã€å¼•ç”¨ã€åˆ‡ç‰‡ã€è¿­ä»£å™¨ã€å®ˆå«
    //æ¨¡å¼åŒ¹é…æ˜¯ç©·å°½çš„ï¼Œå¦‚æœæ²¡æœ‰åŒ¹é…åˆ°ä»»ä½•åˆ†æ”¯ï¼Œç¼–è¯‘å™¨ä¼šæŠ¥é”™
    //matchæœ¬èº«æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå®ƒçš„è¿”å›å€¼æ˜¯æ¯ä¸ªåˆ†æ”¯çš„è¿”å›å€¼çš„å…¬å…±ç±»å‹
    let ip = IpAddrKind::V4;
    let ip_info = match ip {
        IpAddrKind::V4 => IpInfo {
            kind: IpAddrKind::V4,
            address: String::from("localhost"),
        },
        IpAddrKind::V6 => IpInfo {
            kind: IpAddrKind::V6,
            address: String::from("::1"),
        }
    };
    print_IpInfo(ip_info);

    //matchè¡¨è¾¾å¼çš„åˆ†æ”¯å¯ä»¥ä½¿ç”¨æ¨¡å¼ç»‘å®š
    let actions = [
        Action::Say(String::from("hello")),
        Action::MoveTo(1, 2),
        Action::ChangeColor(255, 255, 0),
    ];
    //è¿™é‡Œçš„actionæ˜¯ä¸€ä¸ªæ¨¡å¼ç»‘å®šï¼Œå®ƒä¼šå°†actionsæ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ç»‘å®šåˆ°actionä¸Šï¼Œç„¶åæ‰§è¡Œå¯¹åº”çš„åˆ†æ”¯
    for action in &actions {
        match action {
            Action::Say(s) => {
                println!("say {}", s);
            }
            Action::MoveTo(x, y) => {
                println!("move to ({},{})", x, y);
            }
            Action::ChangeColor(r, g, b) => {
                println!("change color to ({},{},{})", r, g, b);
            }
        }
    }
    //æ¨¡å¼ç»‘å®šçš„å¦ä¸€ç§å†™æ³• if let ï¼›åªè¦åŒ¹é…ä¸€ä¸ªæ¡ä»¶ ä¸”å¿½ç•¥å…¶ä»–æ¡ä»¶æ—¶ç”¨if let
    if let Action::Say(s) = &actions[0] {
        println!("if let say {}", s);
    }

    //matches!å® å¯ä»¥ç”¨æ¥ç®€åŒ–matchè¡¨è¾¾å¼
    let v = vec![IpAddrKind::V4, IpAddrKind::V6];
    v.iter().filter(|x| matches!(x,IpAddrKind::V4)).for_each(|x| print_IpAddrKind(x));

    //å˜é‡é®è”½ æ— è®ºæ˜¯matchè¿˜æ˜¯if let éƒ½ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„å˜é‡ç»‘å®šï¼Œè¿™ä¸ªå˜é‡ç»‘å®šä¼šé®è”½å¤–éƒ¨çš„åŒåå˜é‡
    let x = Some(5);
    println!("before x = {:?}", x);//Some(5)
    if let Some(x) = x {
        println!("xè¢«å˜é‡é®è”½ if let x = {:?}", x); //5
    }
    println!("after x = {:?}", x); //Some(5)

    //Optionè¯¦è§£
    //ä½¿ç”¨Option<T> æ˜¯ä¸ºäº†ä»Someä¸­å–å‡ºå…¶å†…éƒ¨çš„Tå€¼ ä»¥åŠå¤„ç†æ²¡æœ‰å€¼çš„æƒ…å†µ
    let five = Some(5);
    let seven = plus_two(five);
    let none = plus_two(None);
    println!("five = {:?}, seven = {:?}, none = {:?}", five, seven, none);
    // plus_twoæ¥æ”¶ä¸€ä¸ªOption<i32ç±»å‹çš„å‚æ•° è¿”å›ä¸€ä¸ªOption<i32>ç±»å‹çš„å€¼
    // åœ¨è¯¥å‡½æ•°çš„å†…éƒ¨å¤„ç†ä¸­å¦‚æœä¼ å…¥çš„æ˜¯ä¸€ä¸ªNone åˆ™è¿”å›ä¸€ä¸ªNoneä¸”ä¸åšä»»ä½•å¤„ç† å¦‚æœä¼ å…¥çš„æ˜¯ä¸€ä¸ªSome(i32) åˆ™è¿”å›ä¸€ä¸ªSomeä¸”å¯¹Someå†…éƒ¨çš„å€¼åŠ 2

    //é™¤äº†ä¸Šè¿°æåˆ°çš„if letæ¨¡å¼åŒ¹é… ä¹Ÿå¯ä»¥ä½¿ç”¨matchæ¨¡å¼åŒ¹é…
    let mut stack = Vec::new();
    stack.push(1);
    stack.push(2);
    stack.push(3);
    while let Some(top) = stack.pop() {
        println!("top = {}", top);
    }
    //è¿™é‡Œçš„while letå¾ªç¯ä¼šä¸€ç›´æ‰§è¡Œï¼Œç›´åˆ°stack.pop()è¿”å›Noneï¼Œå³stackä¸ºç©º

    //å•åˆ†æ”¯å¤šæ¨¡å¼
    let x = 1;
    match x {
        1 | 2 => {
            println!("x = 1 or 2");
        }
        _ => {
            println!("x = others");
        }
    }
    //é€šè¿‡åºåˆ—..=æ¥åŒ¹é…èŒƒå›´
    let x = 5;
    match x {
        1..=5 => {
            println!("x = 1..=5");
        }
        _ => {
            println!("x = others");
        }
    }
    //è§£æ„å¹¶åˆ†è§£å€¼ï¼šå¯ä»¥ä½¿ç”¨æ¨¡å¼æ¥è§£æ„ç»“æ„ä½“ã€æšä¸¾ã€å…ƒç»„ã€å¼•ç”¨ã€åˆ‡ç‰‡ã€è¿­ä»£å™¨
    //è§£æ„ç»“æ„ä½“
    let user = User {
        username: String::from("å¼ ä¸‰"),
        email: String::from("zhangsan@gmail.com"),
        sign_in_count: 1,
        active: true,
    };
    // let User { username:a, email:b, sign_in_count:c, active:d } = user;
    // //å°†ç»“æ„ä½“çš„å­—æ®µè§£æ„åˆ°å˜é‡ä¸­
    // println!("a = {}, b = {}, c = {}, d = {}", a, b, c, d);
    //ç®€å†™
    let User { username, email, sign_in_count, active } = user;
    println!("username = {}, email = {}, sign_in_count = {}, active = {}", username, email, sign_in_count, active);

    //åŒ¹é…å›ºå®šæŸä¸ªå­—æ®µçš„æ–¹å¼
    struct Point1 {
        x: i32,
        y: i32,
    }
    let p = Point1 { x: 0, y: 2 };
    match p {
        Point1 { x, y: 0 } => println!("xè½´ä¸Š,æ¨ªåæ ‡ = {}", x),
        Point1 { x: 0, y } => println!("yè½´ä¸Š,çºµåæ ‡ = {}", y),
        Point1 { x, y } => println!("x = {}, y = {}", x, y),
    }

    //==================================================================æ–¹æ³•==================================================================

    struct Circle {
        x: f64,
        y: f64,
        radius: f64,
    }
    impl Circle {
        //newæ˜¯Circleçš„å…³è”å‡½æ•°ï¼Œå› ä¸ºå®ƒçš„ç¬¬ä¸€ä¸ªå‚æ•°ä¸æ˜¯selfï¼Œä¸”newä¸æ˜¯å…³é”®å­— è¿™ç§æ–¹æ³•å¾€å¾€ç”¨äºåˆå§‹åŒ–å½“å‰ç»“æ„ä½“å®ä¾‹
        fn new(x: f64, y: f64, radius: f64) -> Circle {
            Circle { x, y, radius }
        }
        // Circleçš„æ–¹æ³• &selfè¡¨ç¤ºå€Ÿç”¨å½“å‰Circleç»“æ„ä½“
        fn area(&self) -> f64 {
            std::f64::consts::PI * (self.radius * self.radius)
        }
    }

    // self &self &mut self
    // åœ¨areaæ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†&selfï¼Œå…¶å®æ˜¯selfï¼š&Selfçš„ç®€å†™ ï¼Œè¿™æ˜¯å› ä¸ºæˆ‘ä»¬ä¸æƒ³è·å–Circleçš„æ‰€æœ‰æƒï¼Œåªæ˜¯æƒ³å€Ÿç”¨å®ƒï¼Œè¿™æ ·Circleå°±ä¸ä¼šè¢«é”€æ¯
    // è€Œselfè¡¨ç¤ºè·å–Circleçš„æ‰€æœ‰æƒï¼Œè¿™æ ·Circleå°±ä¼šè¢«é”€æ¯ï¼Œè¿™ç§æƒ…å†µå¾ˆå°‘è§ &mut selfè¡¨ç¤ºè·å–Circleçš„å¯å˜å€Ÿç”¨
    //å…³è”å‡½æ•°å’Œæ–¹æ³•çš„åŒºåˆ« å…³è”å‡½æ•°æ˜¯å±äºç»“æ„ä½“çš„ï¼Œè€Œæ–¹æ³•æ˜¯å±äºç»“æ„ä½“å®ä¾‹çš„

    struct Rectangle {
        width: u32,
        height: u32,
    }

    impl Rectangle {
        fn area(&self) -> u32 {
            self.width * self.height
        }
        fn can_hold(&self, other: &Rectangle) -> bool {
            self.width > other.width && self.height > other.height
        }
        //rustä¸­ å…è®¸æ–¹æ³•åå’Œç»“æ„ä½“å­—æ®µåç›¸åŒ
        fn width(&self) -> u32 {
            self.width
        }
        //å…³è”å‡½æ•°
        fn square(size: u32) -> Rectangle {
            Rectangle { width: size, height: size }
        }
    }
    let rect = Rectangle { width: 30, height: 50 };
    // å­—æ®µ
    println!("rect.width = {}", rect.width);
    // æ–¹æ³•
    println!("rect.width() = {}", rect.width());

    /*
        NOTICE
        åœ¨C/C++ä¸­æœ‰ä¸¤ä¸ªä¸åŒçš„è¿ç®—ç¬¦ï¼š.å’Œ->æ¥è°ƒç”¨æ–¹æ³•ï¼Œ.ç›´æ¥åœ¨å¯¹è±¡ä¸Šè°ƒç”¨æ–¹æ³• è€Œ->åœ¨å¯¹è±¡çš„æŒ‡é’ˆä¸Šè°ƒç”¨æ–¹æ³• è¿™æ˜¯éœ€è¦å…ˆè§£å¼•ç”¨æŒ‡é’ˆ
        e.g. object->method() ç­‰ä»·äº (*object).method()
        è€Œåœ¨Rustä¸­ï¼Œåªæœ‰.è¿ç®—ç¬¦ï¼Œå®ƒä¼šè‡ªåŠ¨è§£å¼•ç”¨å¯¹è±¡
        æ‰€ä»¥ä¸Šè¿°ä»£ç ä¸­çš„rect.width()ç­‰ä»·äº(&rect).width()
    */
    // å…³è”å‡½æ•° rustå®šä¹‰åœ¨implä¸­ä¸”æ²¡æœ‰selfçš„å‡½æ•°è¢«ç§°ä¸ºå…³è”å‡½æ•° çº¦å®šä¿—æˆä½¿ç”¨newæ¥å®šä¹‰å…³è”å‡½æ•° æ‰€ä»¥rustç‰¹åœ°æ²¡æœ‰æä¾›newå…³é”®å­— å› ä¸ºæ˜¯å‡½æ•°æ‰€ä»¥ä¸èƒ½ç”¨.æ¥è°ƒç”¨
    let square = Rectangle::square(10);

    // å¯ä»¥å®šä¹‰å¤šä¸ªimpl
    impl Rectangle {
        fn print(&self) {
            println!("width = {}, height = {}", self.width, self.height);
        }
    }

    //ä¸ºæšä¸¾å®ç°æ–¹æ³•
    impl Message {
        fn call(&self) {
            println!("call");
        }
    }
    let m = Message::Write(String::from("hello"));
    m.call();
    //=======================æ³›å‹=======================
    //æ³›å‹æ˜¯ä¸€ç§æŠ½è±¡ï¼Œå®ƒé€šè¿‡åœ¨ç¼–è¯‘æ—¶ä¸æŒ‡å®šå…·ä½“ç±»å‹æ¥å®ç°ä»£ç å¤ç”¨
    //ä½¿ç”¨ç‰¹å¾traitæ¥å®ç°æ³›å‹ ä¾‹å¦‚std::ops::Add<Output = T>
    fn add<T: std::ops::Add<Output=T>>(a: T, b: T) -> T {
        a + b
    }
    let a = 1;
    let b = 2;
    let c = add(a, b);
    println!("c = {}", c);
    //ç»“æ„ä½“ä¸­ä½¿ç”¨æ³›å‹
    struct Point2<T> {
        x: T,
        y: T,
    }
    let p1 = Point2 { x: 1, y: 2 };
    let p2 = Point2 { x: 1.0, y: 2.0 };
    // ä¸Šè¿°Point2ç»“æ„ä½“ä¸­çš„xå’Œyå¿…é¡»æ˜¯åŒä¸€ç§ç±»å‹ï¼Œå¦åˆ™ç¼–è¯‘å™¨ä¼šæŠ¥é”™ error[E0308]: mismatched types
    //let _p3 = Point2 { x: 1, y: 2.0 };
    //å¦‚æœæƒ³è¦xå’Œyæ˜¯ä¸åŒçš„ç±»å‹ï¼Œå¯ä»¥ä½¿ç”¨å¤šä¸ªæ³›å‹
    struct Point3<T, U> {
        x: T,
        y: U,
    }
    let p3 = Point3 { x: 1, y: 2.1 };
    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
    //æšä¸¾ä¸­ä½¿ç”¨æ³›å‹ è¯¦è§Option<T> å’Œ Result<T, E>

    //æ–¹æ³•ä¸­ä½¿ç”¨æ³›å‹ ä½¿ç”¨æ³›å‹å‚æ•°å‰ éœ€è¦æå‰å£°æ˜ impl<T>ï¼ˆæ–¹æ³•æ³›å‹ï¼‰ è¿™æ ·æ‰èƒ½åœ¨Point2ä¸­ç”¨å®ƒ
    impl<T> Point2<T> {
        fn x(&self) -> &T {
            &self.x
        }
    }

    let p4 = Point2 { x: 1, y: 2 };
    println!("p4.x = {}", p4.x());

    //ä¸ºå…·ä½“çš„æ³›å‹ç±»å‹å®ç°æ–¹æ³• å³åªå½“Point2çš„å®ä¾‹æ˜¯æŸä¸ªå…·ä½“ç±»å‹ï¼ˆå¦‚f32ï¼‰æ—¶æ‰å®ç°æ–¹æ³•
    impl Point2<f32> {
        fn distance_from_origin(&self) -> f32 {
            (self.x.powi(2) + self.y.powi(2)).sqrt()
        }
    }
    let p5 = Point2 { x: 1.0, y: 2.0 };
    println!("p5.distance_from_origin = {}", p5.distance_from_origin());
    //constæ³›å‹ ä¸€ä¸ªå…¸å‹åº”ç”¨å°±æ˜¯æ³›å‹å®šä¹‰æ•°ç»„é•¿åº¦

    //å®šä¹‰å‡½æ•°å‚æ•°ä¸ºå…ƒç´ ç±»å‹æ˜¯T é•¿åº¦æ˜¯Nï¼ˆusizeï¼‰çš„æ•°ç»„ å¯ä»¥ä¼ å…¥ä»»æ„é•¿åº¦çš„æ•°ç»„
    fn display_array<T: std::fmt::Debug, const N: usize>(arr: [T; N]) {
        println!("arr = {:?}", arr);
    }
    let arr1 = [1, 2, 3];
    let arr2 = [1, 2, 3, 4, 5];
    display_array(arr1);
    display_array(arr2);

    //=======================traitç‰¹å¾=======================
    //ç±»ä¼¼äºgolangçš„interface ä½†éœ€è¦æ˜¾å¼ç»§æ‰¿
    //traitæ˜¯ä¸€ç§å®šä¹‰å…±äº«è¡Œä¸ºçš„æ–¹æ³•ï¼Œå¯ä»¥é€šè¿‡traitæ¥å®šä¹‰å…±äº«çš„è¡Œä¸ºï¼Œç„¶ååœ¨ä¸åŒçš„ç±»å‹ä¸Šå®ç°è¿™äº›traitï¼Œä»è€Œå®ç°å…±äº«è¡Œä¸º
    //å®šä¹‰
    pub trait Summary {
        fn summarize(&self) -> String;
        fn summarizeDefalt(&self) -> String {
            String::from("Read more...")
        }
    }
    pub struct Post {
        pub title: String,
        pub author: String,
        pub content: String,
    }
    impl Summary for Post {
        fn summarize(&self) -> String {
            format!("æ–‡ç« {},ä½œè€…æ˜¯{}", self.title, self.author)
        }
    }
    pub struct Weibo {
        pub username: String,
        pub content: String,
    }

    impl Summary for Weibo {
        fn summarize(&self) -> String {
            format!("{}å‘è¡¨äº†å¾®åš{}", self.username, self.content)
        }
        fn summarizeDefalt(&self) -> String {
            String::from("å¾®åšå†…å®¹å¤ªé•¿äº†ï¼Œä¸æƒ³çœ‹")
        }
    }
    let post = Post { title: "RustDemo".to_string(), author: "zsyu9779".to_string(), content: "Rust great!".to_string() };
    let weibo = Weibo { username: "zsyu9779".to_string(), content: "hello".to_string() };
    println!("post.summarize = {}", post.summarize());
    println!("weibo.summarize = {}", weibo.summarize());
    //ä¸Šé¢çš„Summary è¢«å®šä¹‰æˆäº†pubå…¬å¼€çš„ å¦‚æœä»–äººæƒ³è¦ä½¿ç”¨Summaryç‰¹æ€§ å¯ä»¥å°†å…¶å¼•å…¥åˆ°ä½œç”¨åŸŸä¸­è¿›è¡Œå®ç°
    //å…³äºç‰¹å¾å®ç°ä¸å®šä¹‰çš„ä½ç½® æœ‰ä¸€æ¡éå¸¸é‡è¦çš„åŸåˆ™ å¦‚æœæƒ³ä¸ºç±»å‹Aå®ç°ç‰¹å¾T é‚£ä¹ˆAæˆ–è€…Tè‡³å°‘æœ‰ä¸€ä¸ªæ˜¯åœ¨å½“å‰ä½œç”¨åŸŸä¸­å®šä¹‰çš„
    //e.g. å¦‚æœè¦ä¸ºä¸Šè¿°çš„Postå®ç°æ ‡å‡†åº“ä¸­çš„Displayç‰¹å¾ æ˜¯OKçš„ å› ä¸ºPostå®šä¹‰åœ¨å½“å‰ä½œç”¨åŸŸ åŒæ ·çš„ä¸ºStringå®ç°ä¸Šé¢çš„Summaryç‰¹å¾ä¹Ÿæ˜¯OKçš„
    // ä½†è¦ä¸ºStringå®ç°Displayç‰¹å¾æ˜¯ä¸è¡Œçš„ å› ä¸ºStringæ˜¯æ ‡å‡†åº“ä¸­çš„ç±»å‹ æ²¡æœ‰å®šä¹‰åœ¨å½“å‰å®šä¹‰åŸŸ è¯¥è§„åˆ™è¢«ç§°ä¸ºå­¤å„¿è§„åˆ™ï¼ˆorphan ruleï¼‰ç¡®ä¿å…¶ä»–äººç¼–å†™çš„ä»£ç ä¸ä¼šç ´åä½ çš„ä»£ç 

    //é»˜è®¤å®ç° å¯ä»¥åœ¨traitä¸­å®šä¹‰é»˜è®¤å®ç°ï¼Œè¿™æ ·å…¶ä»–ç±»å‹æ— éœ€å†å®ç°è¯¥æ–¹æ³•ï¼Œæˆ–è€…å¯ä»¥é€‰æ‹©é‡è½½è¯¥æ–¹æ³• è¯¦è§ä¸Šé¢çš„summarizeDefaltæ–¹æ³•
    println!("post.summarizeDefalt = {}", post.summarizeDefalt());
    println!("weibo.summarizeDefalt = {}", weibo.summarizeDefalt());//é‡è½½äº†
    //é»˜è®¤å®ç°å…è®¸è°ƒç”¨ç›¸åŒtraitä¸­çš„å…¶ä»–æ–¹æ³•
    //...

    //traitä½œä¸ºå‚æ•°
    // notifyå‡½æ•°æ¥æ”¶ä¸€ä¸ªå®ç°äº†Summaryç‰¹å¾çš„å‚æ•° è¯¥å‚æ•°å¯ä»¥æ˜¯ä»»æ„å®ç°äº†Summaryç‰¹å¾çš„ç±»å‹(å¯ä»¥ç†è§£ä¸ºinterfaceå‚æ•°ï¼ŒçœŸæ­£è°ƒç”¨æ—¶å®ç°å¤šæ€)
    pub fn notify(item: &impl Summary) {
        println!("notify = {}", item.summarize());
    }
    notify(&post);
    notify(&weibo);
    //ç‰¹å¾çº¦æŸ trait bound
    //è™½ç„¶impl Traitè¿™ç§è¯­æ³•æ˜“äºç†è§£ ä½†å®é™…ä¸Šæ˜¯ä¸€ä¸ªè¯­æ³•ç³– å®Œæ•´å†™æ³•å¦‚ä¸‹
    //pub fn notify<T: Summary>(item: &T) {
    //    println!("notify = {}", item.summarize());
    //}
    //è¿™é‡Œçš„<T: Summary>è¢«ç§°ä¸ºç‰¹å¾çº¦æŸï¼Œå®ƒè¡¨ç¤ºnotifyå‡½æ•°æ¥æ”¶ä¸€ä¸ªå®ç°äº†Summaryç‰¹å¾çš„æ³›å‹å‚æ•°T
    // ç®€å•åœºæ™¯ä¸‹impl Traitæä¾›äº†ç®€æ´çš„è¯­æ³• ä½†æ˜¯å¯¹äºå¤æ‚çš„åœºæ™¯ ç‰¹å¾çº¦æŸå¯ä»¥è®©æˆ‘ä»¬æ‹¥æœ‰æ›´å¤§çš„çµæ´»æ€§å’Œè¯­æ³•è¡¨ç°èƒ½åŠ›ï¼š

    // 1.å¯ä»¥åœ¨å‡½æ•°ä¸­ä½¿ç”¨å¤šä¸ªæ³›å‹å‚æ•°
    pub fn notify1(item1: &impl Summary, item2: &impl Summary) {
        println!("notify1 = {}", item1.summarize());
        println!("notify1 = {}", item2.summarize());
    }
    //NOTICE ä¸Šè¿°ä»£ç ä¸­çš„item1å’Œitem2å¯ä»¥æ˜¯ä¸åŒçš„ç±»å‹ï¼Œåªè¦å®ƒä»¬éƒ½å®ç°äº†Summaryç‰¹å¾ ä½†å¦‚æœæˆ‘ä»¬éœ€è¦é™åˆ¶item1å’Œitem2æ˜¯åŒä¸€ç§ç±»å‹ï¼Œé‚£ä¹ˆå°±éœ€è¦ä½¿ç”¨ç‰¹å¾çº¦æŸï¼š
    pub fn notify2<T: Summary>(item1: &T, item2: &T) {
        println!("notify2 = {}", item1.summarize());
        println!("notify2 = {}", item2.summarize());
    }
    //Test
    notify1(&post, &weibo);
    //notify2(&post,&weibo); //error[E0308]: mismatched types

    // 2.å¯ä»¥åœ¨å‡½æ•°ä¸­ä½¿ç”¨å¤šä¸ªç‰¹å¾çº¦æŸ ä¾‹å¦‚çº¦æŸå‚æ•°å¿…é¡»åŒæ—¶æ»¡è¶³Summaryå’ŒDisplayç‰¹å¾
    pub fn notify3<T: Summary + std::fmt::Display>(item: &T) {
        //å‚æ•°å®ç°äº†Displayç‰¹å¾å°±å¯ä»¥ç›´æ¥æ‰“å‡ºè¿™è¡Œ
        println!("notify3 = {}", item);
    }
    //Test
    impl Display for Post {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "title = {},author = {},content = {}", self.title, self.author, self.content)
        }
    }
    notify3(&post);

    // 3.å¯ä»¥åœ¨å‡½æ•°ä¸­ä½¿ç”¨whereå­å¥æ¥ç®€åŒ–ç‰¹å¾çº¦æŸ
    // å½“ç‰¹å¾çº¦æŸå¾ˆå¤šçš„æ—¶å€™ å‡½æ•°çš„ç­¾åä¼šå˜çš„å¾ˆå¤æ‚
    fn some_fn<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
        0
    }
    //å¯ä»¥ç®€åŒ–ä¸º
    fn some_fn1<T, U>(t: &T, u: &U) -> i32
        where T: Display + Clone,
              U: Clone + Debug
    {
        0
    }
    //whereå­å¥å¯ä»¥å°†ç‰¹å¾çº¦æŸæ”¾åœ¨å‡½æ•°ç­¾åçš„æœ€åï¼Œè¿™æ ·å¯ä»¥è®©å‡½æ•°ç­¾åæ›´åŠ æ¸…æ™°
    //è¿”å›ä¸­çš„impl Trait
    //å¯ä»¥åœ¨å‡½æ•°è¿”å›å€¼ä¸­ä½¿ç”¨impl Traitï¼Œè¿™æ ·å¯ä»¥è¿”å›å®ç°äº†æŸä¸ªç‰¹å¾çš„ç±»å‹ï¼Œè¿™ç§å†™æ³•è¢«ç§°ä¸ºè¿”å›å€¼å¤šæ€ï¼ˆreturn type polymorphismï¼‰
    //...

    //é€šè¿‡deriveæ´¾ç”Ÿç‰¹å¾
    //å½¢å¦‚ #[derive(Debug)]
    //ä¾‹å¦‚ Debug ç‰¹å¾ï¼Œå®ƒæœ‰ä¸€å¥—è‡ªåŠ¨å®ç°çš„é»˜è®¤ä»£ç ï¼Œå½“ä½ ç»™ä¸€ä¸ªç»“æ„ä½“æ ‡è®°åï¼Œå°±å¯ä»¥ä½¿ç”¨ println!("{:?}", s) çš„å½¢å¼æ‰“å°è¯¥ç»“æ„ä½“çš„å¯¹è±¡ã€‚

    //è°ƒç”¨æ–¹æ³•éœ€è¦å¼•å…¥ç‰¹å¾
    let a: i32 = 10;
    let b: u16 = 100;
    let b_ = b.try_into().unwrap();
    if a < b_ {
        println!("a < b");
    }
    //ç‰¹å¾å¯¹è±¡
    //ç‰¹å¾å¯¹è±¡æ˜¯ä¸€ä¸ªå­˜æ”¾äº†å®ç°äº†æŸä¸ªç‰¹å¾çš„ç±»å‹çš„å¯¹è±¡ï¼Œå®ƒå¯ä»¥ç”¨ä½œå‚æ•°æˆ–è¿”å›å€¼ï¼Œè¿™æ ·å¯ä»¥åœ¨è¿è¡Œæ—¶åŠ¨æ€çš„é€‰æ‹©å®ç°äº†æŸä¸ªç‰¹å¾çš„ç±»å‹
    pub trait Draw {
        fn draw(&self);
    }
    pub struct Button {
        pub width: u32,
        pub height: u32,
        pub label: String,
    }
    impl Draw for Button {
        fn draw(&self) {
            println!("Button");
        }
    }
    pub struct SelectBox {
        pub width: u32,
        pub height: u32,
        pub options: Vec<String>,
    }
    impl Draw for SelectBox {
        fn draw(&self) {
            println!("SelectBox");
        }
    }
    //ç‰¹å¾å¯¹è±¡çš„å†™æ³•æ˜¯&dyn Traitï¼Œå®ƒè¡¨ç¤ºä¸€ä¸ªå®ç°äº†Traitç‰¹å¾çš„å¼•ç”¨
    pub struct Screen {
        //åŠ¨æ€æ•°ç»„ å…ƒç´ æ˜¯å®ç°äº†Drawç‰¹å¾çš„ç±»å‹
        pub components: Vec<Box<dyn Draw>>,
    }
    //ä»¥ä¸‹ä»£ç å—è§£é‡ŠBox<dyn Draw>çš„ä½œç”¨
    {
        impl Draw for u8 {
            fn draw(&self) -> String {
                format!("u8 : {}", *self)
            }
        }
        impl Draw for f64 {
            fn draw(&self) -> String {
                format!("u8 : {}", *self)
            }
        }

        //è‹¥Tå®ç°äº†Drawç‰¹å¾ åˆ™è°ƒç”¨è¯¥å‡½æ•°æ—¶ä¼ å…¥çš„Box<T>å¯ä»¥è¢«éšå¼è½¬æ¢æˆå‡½æ•°ç­¾åä¸­çš„Box<dyn Draw>
        fn draw1(x: Box<dyn Draw>) {
            // ç”±äºå®ç°äº†Dereferenceç‰¹å¾ Boxæ™ºèƒ½æŒ‡é’ˆä¼šè‡ªåŠ¨è§£å¼•ç”¨ä¸ºå®ƒæ‰€åŒ…è£¹çš„å€¼ ç„¶åè°ƒç”¨è¯¥å€¼å¯¹åº”çš„ç±»å‹ä¸Šå®šä¹‰çš„drawæ–¹æ³•
            x.draw();
        }

        fn draw2(x: &dyn Draw) {
            x.draw();
        }

        let x = 1.1f64;
        let y = 8u8;

        //xå’Œyéƒ½å®ç°äº†Drawç‰¹å¾ å› ä¸ºBox<T> å®ç°äº†Derefç‰¹å¾ æ‰€ä»¥Box<T>å¯ä»¥è¢«éšå¼è½¬æ¢æˆBox<dyn Draw>
        //åŸºäºxçš„å€¼åˆ›å»ºäº†ä¸€ä¸ªBox<f64>ï¼ŒæŒ‡é’ˆæŒ‡å‘çš„æ•°æ®è¢«æ”¾ç½®åœ¨å †ä¸Š
        draw1(Box::new(x));
        draw1(Box::new(y));
        draw2(&x);
        draw2(&y);
    }

    //æ¥ä¸‹æ¥å®Œå–„Screençš„runæ–¹æ³• ç”¨äºå°†åˆ—è¡¨ä¸­çš„ç»„ä»¶æ¸²æŸ“åœ¨å±å¹•ä¸Š
    impl Screen {
        pub fn run(&self) {
            for component in self.components.iter() {
                component.draw();
            }
        }
    }

    //é€šè¿‡æ³›å‹å®ç°Screenå¦‚ä¸‹
    pub struct Screen1<T: Draw> {
        pub components: Vec<T>,
    }
    impl <T> Screen1<T>
        //whereç‰¹å¾çº¦æŸ æ‰€ä»¥è¿™ç§å†™æ³•æœ‰ä¸ªå¼Šç«¯å°±æ˜¯åˆ—è¡¨ä¸­çš„ç»„ä»¶å¿…é¡»æ˜¯åŒä¸€ç§ç±»å‹ å³å…¨éƒ¨æ˜¯SelectBoxæˆ–å…¨éƒ¨æ˜¯Button
        where T: Draw {
        pub fn run(&self) {
            for component in self.components.iter() {
                component.draw();
            }
        }
    }
    // ç‰¹å¾å¯¹è±¡çš„åŠ¨æ€
}

fn plus_two(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 2),
    }
}

#[derive(Debug)]
enum Action {
    Say(String),
    MoveTo(i32, i32),
    ChangeColor(i32, i32, i32),
}

#[derive(Debug)]
enum IpAddrKind {
    V4,
    V6,
}

#[derive(Debug)]
enum PokerCard {
    Clubs(u8),
    Spades(u8),
    Diamonds(u8),
    Hearts(u8),
}

#[derive(Debug)]
struct IpInfo {
    kind: IpAddrKind,
    address: String,
}

#[derive(Debug)]
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn print_IpAddrKind(ip_kind: &IpAddrKind) {
    println!("ip_kind = {:?}", ip_kind);
}

fn print_IpInfo(ip_info: IpInfo) {
    println!("ip_info = {:?}", ip_info);
}

fn print_PokerCards(poker_cards: &[PokerCard]) {
    for card in poker_cards {
        println!("poker_card = {:?}", card);
    }
}

fn send_Msg(msg: Message) {
    println!("msg = {:?}", msg);
}

struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

fn build_user(email: String, username: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}

fn takes_ownership(some_string: String) { // some_string è¿›å…¥ä½œç”¨åŸŸ
    println!("{}", some_string);
}// some_string ç¦»å¼€ä½œç”¨åŸŸï¼Œdropå‡½æ•°è¢«è°ƒç”¨ï¼Œsome_stringçš„å†…å­˜è¢«é‡Šæ”¾

fn makes_copy(some_integer: i32) { // some_integer è¿›å…¥ä½œç”¨åŸŸ
    println!("{}", some_integer);
}// some_integer ç¦»å¼€ä½œç”¨åŸŸ ä¸ä¼šæœ‰ç‰¹æ®Šæ“ä½œ

fn gives_ownership() -> String { // gives_ownership å°†è¿”å›å€¼ç§»åŠ¨ç»™è°ƒç”¨å®ƒçš„å‡½æ•°
    let some_string = String::from("hello"); // some_string è¿›å…¥ä½œç”¨åŸŸ
    some_string // some_string è¢«è¿”å›å¹¶ç§»å‡ºå‡½æ•°
}

fn takes_and_gives_back(a_string: String) -> String { // a_string è¿›å…¥ä½œç”¨åŸŸ
    a_string // a_string è¢«è¿”å›å¹¶ç§»å‡ºå‡½æ•°
}

fn calculate_length(s: &String) -> usize {
    s.len()
}// å› ä¸ºå‡½æ•°ä¸æ‹¥æœ‰sçš„æ‰€æœ‰æƒï¼Œæ‰€ä»¥sç¦»å¼€ä½œç”¨åŸŸåä¸ä¼šè¢«drop

fn change(some_string: &mut String) { //è¿™é‡Œä¼ é€’çš„æ˜¯å¯å˜å¼•ç”¨
    some_string.push_str(", world");
}

fn calculate_length2(s: String) -> (String, usize) {
    let len = s.len();
    (s, len)
}


// fn dangle() -> &String { // dangle è¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²çš„å¼•ç”¨
//    let s = String::from("hello"); // s æ˜¯ä¸€ä¸ªæ–°å­—ç¬¦ä¸²
//    &s // è¿”å›å­—ç¬¦ä¸² s çš„å¼•ç”¨
// } // è¿™é‡Œ s ç¦»å¼€ä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒã€‚å…¶å†…å­˜è¢«é‡Šæ”¾ã€‚

fn first_word(s: &String) -> &str {
    &s[..1]
}

struct Struct {
    e: i32,
}
