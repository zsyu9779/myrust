use num::complex::Complex;

fn main() {
    //++++++++++++++++++++++++++++++++++++++++++++++++++++å˜é‡ç»‘å®šä¸è§£æ„++++++++++++++++++++++++++++++++++++++++++++++++++++++
    let a = "hello world!";
    println!("{}", a);

    // let b = 5; åˆ›å»ºçš„æ˜¯ä¸å¯å˜å˜é‡
    let mut b = 5;
    println!("{}", b);
    b = 6;
    println!("{}", b);

    let _x = 5;
    let _y = 10;

    let (aa, mut bb): (bool, bool) = (true, false);
    println!("aa = {:?}, bb = {:?}", aa, bb);
    bb = true;
    assert_eq!(aa, bb);

    let (a, b, c, d, e);
    (a, b) = (1, 2);
    [c, .., d, _] = [1, 2, 3, 4, 5];
    Struct { e, .. } = Struct { e: 5 };
    assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]);

    //===============å˜é‡é®è”½=====================
    let x = 5;
    //åœ¨mainå‡½æ•°çš„ä½œç”¨åŸŸå¯¹xè¿›è¡Œé®è”½
    let x = x + 1;

    {
        //åœ¨{}çš„ä½œç”¨åŸŸå†…å¯¹xè¿›è¡Œé®è”½
        let x = x * 2;
        println!("the x in scope is {}", x)
    }
    println!("the x in main is {}", x);
    /*
        ä»¥ä¸Šå†™æ³•å’Œmutå˜é‡ä¸åŒç‚¹æ˜¯ mut å¯ä»¥ä¿®æ”¹åœ¨åŒä¸€ä¸ªå†…å­˜åœ°å€ä¸Šçš„å€¼ï¼Œä¸ä¼šå‘ç”Ÿå†…å­˜å¯¹è±¡çš„å†åˆ†é…ï¼Œæ€§èƒ½æ›´å¥½
        è€Œå˜é‡é®è”½ç”Ÿæˆäº†å®Œå…¨ä¸åŒçš„æ–°å˜é‡ï¼Œåªæ˜¯åˆšå¥½åŒåã€‚å˜é‡é®è”½çš„ç”¨å¤„åœ¨äºï¼Œå¦‚æœä½ åœ¨æŸä¸ªä½œç”¨åŸŸå†…æ— éœ€å†ä½¿ç”¨ä¹‹å‰çš„å˜é‡ï¼ˆåœ¨è¢«é®è”½åï¼Œæ— æ³•å†è®¿é—®åˆ°ä¹‹å‰çš„åŒåå˜é‡ï¼‰ï¼Œå°±å¯ä»¥é‡å¤çš„ä½¿ç”¨å˜é‡åå­—ï¼Œè€Œä¸ç”¨ç»å°½è„‘æ±å»æƒ³æ›´å¤šçš„åå­—ã€‚
    */

    //++++++++++++++++++++++++++++++++++++++++++++++++++++åŸºæœ¬ç±»å‹++++++++++++++++++++++++++++++++++++++++++++++++++++++

    //===============æ•°å€¼ç±»å‹=====================

    //æ•´å½¢æº¢å‡º
    //let a :u8 = 256; //è¿™ç§å†™æ³•æ­£å¸¸æƒ…å†µåœ¨ç¼–è¯‘æ—¶ä¼šæŠ¥é”™: the literal `256` does not fit into the type `u8` whose range is `0..=255`
    let a: u8 = 255;
    /*
        ä½¿ç”¨ wrapping_* æ–¹æ³•åœ¨æ‰€æœ‰æ¨¡å¼ä¸‹éƒ½æŒ‰ç…§è¡¥ç å¾ªç¯æº¢å‡ºè§„åˆ™å¤„ç†ï¼Œä¾‹å¦‚ wrapping_add
        å¦‚æœä½¿ç”¨ checked_* æ–¹æ³•æ—¶å‘ç”Ÿæº¢å‡ºï¼Œåˆ™è¿”å› None å€¼
        ä½¿ç”¨ overflowing_* æ–¹æ³•è¿”å›è¯¥å€¼å’Œä¸€ä¸ªæŒ‡ç¤ºæ˜¯å¦å­˜åœ¨æº¢å‡ºçš„å¸ƒå°”å€¼
        ä½¿ç”¨ saturating_* æ–¹æ³•ä½¿å€¼è¾¾åˆ°æœ€å°å€¼æˆ–æœ€å¤§å€¼
     */
    let b = a.wrapping_add(20);
    let c = a.wrapping_mul(2);
    println!("a = {}", a);
    println!("b = {}", b);
    println!("c = {}", c);

    //æµ®ç‚¹ç±»å‹
    //ä¸¤ç§åŸºæœ¬ç±»å‹ f32 å’Œ f64
    let x = 0.1; // f64
    let y: f32 = 0.02; // f32
    /*
        Rust çš„æµ®ç‚¹æ•°ç±»å‹éµå¾ª IEEE-754 æ ‡å‡†
        æµ®ç‚¹æ•°å¤§éƒ¨åˆ†æƒ…å†µä¸‹æ˜¯ä¸ç²¾ç¡®çš„ï¼Œæ‰€ä»¥ä¸è¦ç”¨ == æ¯”è¾ƒæµ®ç‚¹æ•°
    */
    assert_eq!(x + y == 0.12, false);
    /*
    thread 'main' panicked at 'assertion failed: `(left == right)`
    left: `0.120000005`,
    right: `0.12`', src/main.rs:69:5
    */

    let abc: (f32, f32, f32) = (0.1, 0.2, 0.3);
    let xyz: (f64, f64, f64) = (0.1, 0.2, 0.3);

    println!("abc (f32)");
    println!("   0.1 + 0.2: {:x}", (abc.0 + abc.1).to_bits());
    println!("         0.3: {:x}", (abc.2).to_bits());
    println!();

    println!("xyz (f64)");
    println!("   0.1 + 0.2: {:x}", (xyz.0 + xyz.1).to_bits());
    println!("         0.3: {:x}", (xyz.2).to_bits());
    println!();

    assert_eq!(abc.0 + abc.1, abc.2);
    // ç”±äºf64ç²¾åº¦é«˜äºf32 æ‰€ä»¥ä¸‹é¢è¿™ä¸ªæ–­è¨€ä¼španic
    //assert_eq!(xyz.0 + xyz.1, xyz.2);

    //========NaN=====
    //NaN æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„æµ®ç‚¹æ•°ï¼Œè¡¨ç¤ºéæ•°å­—ï¼ˆNot a Numberï¼‰
    //NaN ä¸ä»»ä½•å€¼éƒ½ä¸ç›¸ç­‰ï¼ŒåŒ…æ‹¬å®ƒè‡ªå·±
    let nan = (-42.0_f32).sqrt();
    assert_eq!(nan != nan, true);
    //åˆ¤æ–­ä¸€ä¸ªå€¼æ˜¯å¦æ˜¯nan ä½¿ç”¨ is_nan æ–¹æ³•
    assert_eq!(nan.is_nan(), true);

    //æ•°å€¼è¿ç®— æ²¡ä»€ä¹ˆç‰¹åˆ«
    // åŠ æ³•
    let sum = 5 + 10;

    // å‡æ³•
    let difference = 95.5 - 4.3;

    // ä¹˜æ³•
    let product = 4 * 30;

    // é™¤æ³•
    let quotient = 56.7 / 32.2;

    // æ±‚ä½™
    let remainder = 43 % 5;

    println!("sum = {}, difference = {}, product = {}, quotient = {}, remainder = {}", sum, difference, product, quotient, remainder);

    //èµ‹å€¼æ–¹æ³•
    //ç¼–è¯‘å™¨ä¼šæ ¹æ®å€¼è‡ªåŠ¨æ¨æ–­å˜é‡ç±»å‹
    let _a = 20;
    //æ˜¾å¼æŒ‡å®šç±»å‹
    let _a: i32 = 20;
    //åç¼€æŒ‡å®šç±»å‹
    let _a = 20i32;
    let _a = 20_i32;
    //åŒæ ·ç±»å‹çš„å˜é‡æ‰å¯ä»¥è¿ç®—

    //å¯¹äºè¾ƒé•¿çš„æ•°å­—ï¼Œå¯ä»¥ä½¿ç”¨ä¸‹åˆ’çº¿æ¥æé«˜å¯è¯»æ€§
    let a = 1_000_000;
    println!("a = {}", a);

    // å®šä¹‰ä¸€ä¸ªf32æ•°ç»„ï¼Œå…¶ä¸­42.0ä¼šè‡ªåŠ¨è¢«æ¨å¯¼ä¸ºf32ç±»å‹
    let forty_twos = [
        42.0,
        42f32,
        42.0_f32,
    ];
    // æ‰“å°æ•°ç»„ä¸­ç¬¬ä¸€ä¸ªå€¼ï¼Œå¹¶æ§åˆ¶å°æ•°ä½ä¸º2ä½
    println!("{:.2}", forty_twos[0]);

    //===============ä½è¿ç®—=====================
    let a: i32 = 2; // äºŒè¿›åˆ¶ 0000 0010
    let b: i32 = 3; // äºŒè¿›åˆ¶ 0000 0011
    println!("a & b = {}", a & b); // 0000 0010
    println!("a | b = {}", a | b); // 0000 0011
    println!("a ^ b = {}", a ^ b); // 0000 0001
    println!("!a = {}", !a); // 1111 1101
    println!("a << 1 = {}", a << 1); // 0000 0100
    println!("a >> 1 = {}", a >> 1); // 0000 0001

    //===============åºåˆ—=====================
    // rustæä¾›äº†ä¸€ç§ç®€ä»‹çš„æ–¹å¼ ç”Ÿæˆè¿ç»­çš„æ•°å­—åºåˆ—
    // .. ç”Ÿæˆä¸€ä¸ªå·¦é—­å³å¼€çš„åŒºé—´
    for i in 0..5 {
        println!("i = {}", i);
    }
    // ..= ç”Ÿæˆä¸€ä¸ªå·¦é—­å³é—­çš„åŒºé—´
    for i in 5..=10 {
        println!("i = {}", i);
    }
    //åºåˆ—åªå…è®¸ç”¨äºæ•´æ•°æˆ–å­—ç¬¦ç±»å‹ å› ä¸ºä»–ä»¬å¯ä»¥è¿ç»­
    for c in 'a'..='z' {
        print!("{}  ", c);
    }
    //ä½¿ç”¨aså®Œæˆç±»å‹è½¬æ¢
    for i in 0..5 {
        println!("i = {:.2}", i as f32);
    }

    //æœ‰ç†æ•°å’Œå¤æ•° æœ‰ç†æ•°å’Œå¤æ•°æœªåŒ…å«åœ¨æ ‡å‡†åº“ä¸­ï¼Œéœ€è¦å¼•å…¥ç¬¬ä¸‰æ–¹åº“

    let a = Complex { re: 1.0, im: 2.0 };
    let b = Complex::new(3.0, 4.0);
    let result = a + b;
    println!("result = {}", result);

    //rustä¸­çš„å­—ç¬¦ç±»å‹
    let c = 'å¼ '; //å•ä¸ªæ±‰å­—
    let emoji = 'ğŸ˜»'; //emojiè¡¨æƒ…
    let japanese = 'ã®'; //æ—¥æ–‡
    println!("c = {}, emoji = {}, japanese = {}", c, emoji, japanese);
    //rustä¸­çš„å­—ç¬¦ç±»å‹æ˜¯32ä½çš„ï¼Œå¯ä»¥å­˜å‚¨ä»»æ„çš„unicodeå­—ç¬¦
    println!("å­—ç¬¦'å¼ 'å ç”¨äº†{}ä¸ªå­—èŠ‚", std::mem::size_of_val(&c));

    //====================å¸ƒå°”ç±»å‹====================
    let _b = true;
    let b: bool = false;
    if !b { println!("b is {}", b) }

    //====================å•å…ƒ====================
    //å•å…ƒç±»å‹()ï¼Œä¹Ÿè¢«ç§°ä¸ºunitç±»å‹ï¼Œå®ƒåªæœ‰ä¸€ä¸ªå€¼ï¼Œä¹Ÿå°±æ˜¯()ï¼Œå®ƒåœ¨å‡½æ•°æ²¡æœ‰è¿”å›å€¼æ—¶ä½¿ç”¨
    //å¯ä»¥ç”¨ () ä½œä¸º map çš„å€¼ï¼Œè¡¨ç¤ºæˆ‘ä»¬ä¸å…³æ³¨å…·ä½“çš„å€¼ï¼Œåªå…³æ³¨ keyã€‚ è¿™ç§ç”¨æ³•å’Œ Go è¯­è¨€çš„ struct{} ç±»ä¼¼ï¼Œå¯ä»¥ä½œä¸ºä¸€ä¸ªå€¼ç”¨æ¥å ä½ï¼Œä½†æ˜¯å®Œå…¨ä¸å ç”¨ä»»ä½•å†…å­˜ã€‚

    //=======================è¯­å¥å’Œè¡¨è¾¾å¼=======================
    // å‡½æ•°
    fn add_with_extra(a: i32, b: i32) -> i32 {
        // è¯­å¥ä¼šæ‰§è¡Œä¸€äº›æ“ä½œï¼Œä½†æ˜¯ä¸è¿”å›å€¼
        let a = a + 1; //è¯­å¥
        let b = b + 1; //è¯­å¥
        // è¡¨è¾¾å¼ä¼šè¿”å›ä¸€äº›å€¼
        a + b //è¡¨è¾¾å¼
    }
    println!("add_with_extra(1, 2) = {}", add_with_extra(1, 2));
    //è¡¨è¾¾å¼ä¸èƒ½åŒ…å«åˆ†å· åœ¨è¡¨è¾¾å¼ååŠ ä¸Šåˆ†å·å°±ä¼šå˜æˆä¸€æ¡è¯­å¥ ä¸ä¼šè¿”å›å€¼
    //å¦‚æœè¡¨è¾¾å¼ä¸è¿”å›ä»»ä½•å€¼ï¼Œä¼šéšå¼è¿”å›ä¸€ä¸ªå•å…ƒç±»å‹çš„å€¼()
    // ifè¯­å¥å—ä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ å¯ä»¥ç”¨äºèµ‹å€¼ ç±»ä¼¼ä¸‰å…ƒè¡¨è¾¾å¼
    let a = 1;
    let b = if a%2==1 { "odd" }else { "even" };
    println!("b = {}", b);

    //=======================å‡½æ•°=======================
    //å‡½æ•°çš„å‚æ•°å¿…é¡»å£°æ˜ç±»å‹,å‡½æ•°åå’Œå‚æ•°åå¿…é¡»ä½¿ç”¨snake_caseé£æ ¼,
    fn add_two(a:i32,b:i32)->i32{
        a+b
    }
    println!("add_two(1,2) = {}",add_two(1,2));
    //å‡½æ•°ä¹Ÿæ˜¯è¡¨è¾¾å¼,å¯ä»¥æŠŠå‡½æ•°çš„è¡¨è¾¾å¼ç›´æ¥èµ‹å€¼ç»™å˜é‡
    fn plus_five(a:i32)->i32{
        a+5
    }
    let f = plus_five(1);
    println!("f = {}",f);

    //å‘æ•£å‡½æ•° diverging function ä¸€èˆ¬ç”¨äºpanic ç”¨!ä½œå‡½æ•°è¿”å›ç±»å‹çš„æ—¶å€™ï¼Œè¡¨ç¤ºè¿™ä¸ªå‡½æ•°æ°¸è¿œä¸ä¼šè¿”å›
    fn _diverges()->!{
        panic!("This function never returns!");
    }
    //è¿˜æœ‰å¦ä¸€ç§å‘æ•£å‡½æ•°ï¼Œå°±æ˜¯ loop å¾ªç¯ï¼Œå®ƒæ°¸è¿œä¸ä¼šç»“æŸ
    fn _diverges2()->!{
        loop{}
    }

    //++++++++++++++++++++++++++++++++++++++++++++++++++++++æ‰€æœ‰æƒå’Œå€Ÿç”¨+++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //=======================æ‰€æœ‰æƒ=======================
    //æ‰€æœ‰æƒæ˜¯rustçš„ä¸€ä¸ªæ ¸å¿ƒæ¦‚å¿µï¼Œå®ƒæ˜¯ä¸€ç§å†…å­˜ç®¡ç†æœºåˆ¶ï¼Œå®ƒå¯ä»¥ä¿è¯å†…å­˜å®‰å…¨ï¼ŒåŒæ—¶ä¹Ÿä¸éœ€è¦åƒåœ¾å›æ”¶æœºåˆ¶
    //å˜é‡ä½œç”¨åŸŸ Rustä¸­æ¯ä¸ªå€¼éƒ½è¢«ä¸€ä¸ªå˜é‡æ‰€æ‹¥æœ‰ï¼Œå½“å˜é‡ç¦»å¼€ä½œç”¨åŸŸï¼Œè¿™ä¸ªå€¼å°±è¢«ä¸¢å¼ƒäº†
    {
        let s = "hello"; //sè¿›å…¥ä½œç”¨åŸŸ
        println!("{}",s);
    }//sç¦»å¼€ä½œç”¨åŸŸï¼Œè¢«ä¸¢å¼ƒ

    let _s = "hello"; //å­—ç¬¦ä¸²å­—é¢é‡ ä¸å¯å˜ ä¿å­˜åœ¨æ ˆä¸Š
    let mut s_string = String::from("hello"); //å­—ç¬¦ä¸²å¯¹è±¡ å¯å˜
    s_string.push_str(", world!"); //push_str() åœ¨å­—ç¬¦ä¸²åè¿½åŠ å­—é¢é‡
    println!("{}", s_string);

    //è½¬ç§»æ‰€æœ‰æƒ
    let x = 5;
    let y = x; //xçš„å€¼è¢«å¤åˆ¶åˆ°yï¼Œå› ä¸ºi32æ˜¯åŸºæœ¬ç±»å‹ï¼Œæ‰€ä»¥xå’Œyéƒ½æ˜¯5 è¿™é‡Œæ²¡æœ‰å‘ç”Ÿæ‰€æœ‰æƒè½¬ç§» å› ä¸ºi32æ˜¯Copyç±»å‹(æ•´æ•°ç±»å‹ï¼Œå›ºå®šå¤§å°çš„ç®€å•å€¼ éƒ½è¢«å­˜åœ¨æ ˆä¸Š)
    println!("x = {}, y = {}",x,y);

    let s1 = String::from("hello");
    let _s2 = s1;
    //s1çš„å€¼è¢«å¤åˆ¶åˆ°s2ï¼Œä½†æ˜¯s1çš„å€¼æ˜¯æŒ‡å‘å †ä¸Šçš„å†…å­˜åœ°å€ï¼Œæ‰€ä»¥s1å’Œs2éƒ½æŒ‡å‘äº†åŒä¸€å—å†…å­˜åœ°å€
    //è¿™é‡Œå‘ç”Ÿäº†æ‰€æœ‰æƒè½¬ç§»ï¼Œs1å¤±æ•ˆäº†ï¼Œä¸èƒ½å†ä½¿ç”¨,å› ä¸ºå‡è®¾è¿™é‡Œæ²¡æœ‰å‘ç”Ÿæ‰€æœ‰æƒè½¬ç§» s1å’Œs2éƒ½æœ‰æ„ä¹‰ï¼ŒæŒ‡å‘äº†åŒä¸€å—å†…å­˜åœ°å€ï¼Œ
    //é‚£ä¹ˆå½“s1å’Œs2éƒ½ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå°±ä¼šå‘ç”Ÿä¸¤æ¬¡é‡Šæ”¾å†…å­˜çš„æ“ä½œï¼Œè¿™å°±æ˜¯æ‰€è°“çš„double freeï¼Œè¿™æ˜¯ä¸€ç§å†…å­˜å®‰å…¨é—®é¢˜ï¼Œrustç¼–è¯‘å™¨ä¼šé˜»æ­¢è¿™ç§æƒ…å†µçš„å‘ç”Ÿ
    //println!("s1 = {}, s2 = {}",s1,s2);
    /*
        //è¿™é‡Œä¼šæŠ¥é”™ï¼Œå› ä¸ºs1å·²ç»å¤±æ•ˆäº†
        255 |     let s1 = String::from("hello");
            |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
        256 |     let s2 = s1;
            |              -- value moved here
        ...
        260 |     println!("s1 = {}, s2 = {}",s1,s2);
            |                                 ^^ value borrowed here after move
    */
    let x : &str = "hello";
    let y = x;
    //è¿™é‡Œxåªå­˜å‚¨äº†å¯¹helloçš„å¼•ç”¨ï¼Œèµ‹å€¼ç»™yçš„è¿‡ç¨‹å¹¶æ²¡æœ‰å‘ç”Ÿæ‰€æœ‰æƒè½¬ç§»ï¼Œå› ä¸º&stræ˜¯ä¸€ä¸ªæŒ‡å‘å­—ç¬¦ä¸²å­—é¢é‡çš„å¼•ç”¨ï¼Œå®ƒæ˜¯ä¸€ä¸ªå›ºå®šå¤§å°çš„å€¼ï¼Œå­˜å‚¨åœ¨æ ˆä¸Š
    println!("x = {}, y = {}",x,y);

    //=====æ·±æ‹·è´=======
    //Rustä¸ä¼šè‡ªåŠ¨åˆ›å»ºæ•°æ®çš„æ·±æ‹·è´
    let s1 = String::from("hello");
    let s2 = s1.clone(); // æ˜¾å¼è°ƒç”¨cloneæ–¹æ³• å®Œæ•´æ‹·è´s1åœ¨å †ä¸Šçš„æ•°æ®
    println!("s1 = {}, s2 = {}",s1,s2);
    //NOTICE cloneä¼šå¯¹æ‰€æœ‰æ•°æ®è¿›è¡Œæ·±æ‹·è´ï¼Œè¿™ä¼šæ¶ˆè€—å¾ˆå¤šèµ„æºï¼Œæ‰€ä»¥åœ¨rustä¸­ï¼Œæ·±æ‹·è´æ˜¯æ˜¾å¼çš„ï¼Œè€Œä¸æ˜¯éšå¼çš„

    //=====æµ…æ‹·è´=======
    //æµ…æ‹·è´åªå‘ç”Ÿåœ¨æ ˆä¸Š å¯Copyçš„ç±»å‹æœ‰ï¼šæ•´æ•°ç±»å‹ã€æµ®ç‚¹ç±»å‹ã€å¸ƒå°”ç±»å‹ã€å­—ç¬¦ç±»å‹ã€å…ƒç»„ç±»å‹(å…¶ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯Copyç±»å‹)

    //=====æ‰€æœ‰æƒå’Œå‡½æ•°=======
    //æ‰€æœ‰æƒä¹Ÿä¼šå‘ç”Ÿåœ¨å‡½æ•°è°ƒç”¨ä¸­ ä¾‹å¦‚
    let s = String::from("hello");
    takes_ownership(s); //sçš„å€¼è¢«ç§»åŠ¨åˆ°å‡½æ•°é‡Œ
    //println!("{}",s); //è¿™é‡Œä¼šæŠ¥é”™ï¼Œå› ä¸ºså·²ç»å¤±æ•ˆäº†
    let x = 5;
    makes_copy(x); //xçš„å€¼è¢«å¤åˆ¶åˆ°å‡½æ•°é‡Œ
    println!("{}",x); //è¿™é‡Œä¸ä¼šæŠ¥é”™ï¼Œå› ä¸ºxæ˜¯Copyç±»å‹ï¼Œæ‰€ä»¥xçš„å€¼æ²¡æœ‰å‘ç”Ÿæ‰€æœ‰æƒè½¬ç§»ï¼Œxä»ç„¶æœ‰æ•ˆ

    //=====è¿”å›å€¼å’Œä½œç”¨åŸŸ=======
    //è¿”å›å€¼ä¹Ÿä¼šå‘ç”Ÿæ‰€æœ‰æƒè½¬ç§»

    let s1 = gives_ownership(); // gives_ownership å°†è¿”å›å€¼ç§»åŠ¨ç»™ s1
    let s2 = String::from("hello"); // s2 è¿›å…¥ä½œç”¨åŸŸ
    let s3 = takes_and_gives_back(s2); // s2 è¢«ç§»åŠ¨åˆ° takes_and_gives_back ä¸­,å®ƒä¹Ÿå°†è¿”å›å€¼ç§»åŠ¨ç»™ s3
    println!("s1 = {}, s3 = {}",s1,s3); //è¿™é‡Œå¦‚æœå°è¯•æ‰“å°s2ä¼šæŠ¥é”™ï¼Œå› ä¸ºs2å·²ç»å¤±æ•ˆäº†

}

fn takes_ownership(some_string: String) { // some_string è¿›å…¥ä½œç”¨åŸŸ
    println!("{}", some_string);
}// some_string ç¦»å¼€ä½œç”¨åŸŸï¼Œdropå‡½æ•°è¢«è°ƒç”¨ï¼Œsome_stringçš„å†…å­˜è¢«é‡Šæ”¾

fn makes_copy(some_integer: i32) { // some_integer è¿›å…¥ä½œç”¨åŸŸ
    println!("{}", some_integer);
}// some_integer ç¦»å¼€ä½œç”¨åŸŸ ä¸ä¼šæœ‰ç‰¹æ®Šæ“ä½œ

fn gives_ownership() -> String { // gives_ownership å°†è¿”å›å€¼ç§»åŠ¨ç»™è°ƒç”¨å®ƒçš„å‡½æ•°
    let some_string = String::from("hello"); // some_string è¿›å…¥ä½œç”¨åŸŸ
    some_string // some_string è¢«è¿”å›å¹¶ç§»å‡ºå‡½æ•°
}

fn takes_and_gives_back(a_string: String) -> String { // a_string è¿›å…¥ä½œç”¨åŸŸ
    a_string // a_string è¢«è¿”å›å¹¶ç§»å‡ºå‡½æ•°
}

struct Struct {
    e: i32,
}
